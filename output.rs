pub use __cargo_equip::prelude::*;use std::io::{stdin,stdout,BufReader,BufWriter,Stdin,StdoutLock,Write};pub mod segtree{pub use crate::__cargo_equip::prelude::*;mod dynamic{pub use crate::__cargo_equip::prelude::*;mod li_chao{pub use crate::__cargo_equip::prelude::*;use super::{convert_range_isize,Node,Zst};use std::ops::{Range,RangeBounds};#[derive(Debug,Clone,Copy)]pub struct Affine{a:isize,b:isize,}impl Affine{fn eval(self,x:isize)->isize{self.a.saturating_mul(x).saturating_add(self.b)}}impl From<(isize,isize)>for Affine{fn from(value:(isize,isize))->Self{Affine{a:value.0,b:value.1}}}type LiChaoTreeNode=Node<Affine,Zst>;#[derive(Debug,Clone)]pub struct LiChaoTree{range:Range<isize>,nodes:Vec<LiChaoTreeNode>,}impl LiChaoTree{pub fn new(range:impl RangeBounds<isize>)->Self{Self{range:convert_range_isize(isize::MIN,isize::MAX,range),nodes:vec![LiChaoTreeNode::new((0,isize::MAX).into(),Zst)],}}pub fn len(&self)->usize{self.range.len()}pub fn is_empty(&self)->bool{self.len()==0}fn create_node(&mut self)->u32{let res=self.nodes.len();let node=LiChaoTreeNode::new((0,isize::MAX).into(),Zst);self.nodes.push(node);res as u32}fn do_add_line(&mut self,val:Affine,l:isize,r:isize,now:usize){if r-l==1{if val.eval(l)<self.nodes[now].val.eval(l){self.nodes[now].val=val;}return;}let(nl,nr)=(val.eval(l),val.eval(r));let(pl,pr)=(self.nodes[now].val.eval(l),self.nodes[now].val.eval(r));if nl<=pl&&nr<=pr{self.nodes[now].val=val;return;}if nl>=pl&&nr>=pr{return;}let mid=(r+l)>>1;if self.nodes[now].left==u32::MAX{let left=self.create_node();self.nodes[now].left=left;self.nodes[left as usize].val=val;}else{self.do_add_line(val,l,mid,self.nodes[now].left as usize);}if self.nodes[now].right==u32::MAX{let right=self.create_node();self.nodes[now].right=right;self.nodes[right as usize].val=val;}else{self.do_add_line(val,mid,r,self.nodes[now].right as usize);}}#[inline]pub fn add_line(&mut self,val:impl Into<Affine>){self.do_add_line(val.into(),self.range.start,self.range.end,0);}fn do_add_segment(&mut self,val:Affine,start:isize,end:isize,l:isize,r:isize,now:usize,){if start<=l&&r<=end{self.do_add_line(val,l,r,now);return;}if r<=start||end<=l{return;}let mid=(r+l)>>1;if start<mid{if self.nodes[now].left==u32::MAX{self.nodes[now].left=self.create_node();}self.do_add_segment(val,start,end,l,mid,self.nodes[now].left as usize);}if mid<=end{if self.nodes[now].right==u32::MAX{self.nodes[now].right=self.create_node();}self.do_add_segment(val,start,end,mid,r,self.nodes[now].right as usize);}}#[inline]pub fn add_segment(&mut self,val:impl Into<Affine>,range:impl RangeBounds<isize>){let Range{start,end}=convert_range_isize(self.range.start,self.range.end,range);self.do_add_segment(val.into(),start,end,self.range.start,self.range.end,0);}fn do_evaluate(&self,x:isize,l:isize,r:isize,now:u32)->isize{if l>=r||now==u32::MAX{return isize::MAX;}let mut res=self.nodes[now as usize].val.eval(x);if r-l==1{return res;}let mid=(r+l)>>1;if x<mid{res=res.min(self.do_evaluate(x,l,mid,self.nodes[now as usize].left));}else{res=res.min(self.do_evaluate(x,mid,r,self.nodes[now as usize].right));}res}pub fn evaluate(&self,x:isize)->isize{self.do_evaluate(x,self.range.start,self.range.end,0)}}#[cfg(test)]mod tests{pub use crate::__cargo_equip::prelude::*;use super::*;#[test]fn line_add_get_min_test(){let mut lct=LiChaoTree::new(-1_000_000_010..1_000_000_010isize);lct.add_line((-1,-1));lct.add_line((0,1));assert_eq!(lct.evaluate(-1),0);assert_eq!(lct.evaluate(-2),1);assert_eq!(lct.evaluate(0),-1);assert_eq!(lct.evaluate(2),-3);lct.add_line((0,-10));assert_eq!(lct.evaluate(-2),-10);assert_eq!(lct.evaluate(0),-10);assert_eq!(lct.evaluate(2),-10);}}}use std::ops::{Range,RangeBounds};use super::{convert_range_isize,Monoid};pub use li_chao::*;#[derive(Debug,Clone)]struct Node<T,L>{left:u32,right:u32,val:T,_lazy:L,}impl<T,L>Node<T,L>{fn new(val:T,lazy:L)->Self{Self{left:u32::MAX,right:u32::MAX,val,_lazy:lazy}}}#[derive(Debug,Clone,Copy)]struct Zst;impl Monoid for Zst{type M=Self;fn id()->Self::M{Zst}fn op(_:&Self::M,_:&Self::M)->Self::M{Zst}}type SegtreeNode<T> =Node<T,Zst>;pub struct DynamicSegmentTree<T:Monoid>{range:Range<isize>,nodes:Vec<SegtreeNode<T::M>>,}impl<T:Monoid>DynamicSegmentTree<T>{pub fn new(range:impl RangeBounds<isize>)->Self{Self{range:convert_range_isize(isize::MIN,isize::MAX,range),nodes:vec![SegtreeNode::new(T::id(),Zst)],}}pub fn len(&self)->usize{self.range.len()}pub fn is_empty(&self)->bool{self.len()==0}fn create_node(&mut self)->u32{let res=self.nodes.len();let node=SegtreeNode::new(T::id(),Zst);self.nodes.push(node);res as u32}fn do_set(&mut self,index:isize,val:T::M,l:isize,r:isize,now:usize){if r-l==1{self.nodes[now].val=val;return;}let mid=(r+l)>>1;if index<mid{if self.nodes[now].left==u32::MAX{self.nodes[now].left=self.create_node();}self.do_set(index,val,l,mid,self.nodes[now].left as usize);}else{if self.nodes[now].right==u32::MAX{self.nodes[now].right=self.create_node();}self.do_set(index,val,mid,r,self.nodes[now].right as usize);}let SegtreeNode{left,right,..}=self.nodes[now];self.nodes[now].val=T::op(self.nodes.get(left as usize).map_or(&T::id(),|n|&n.val),self.nodes.get(right as usize).map_or(&T::id(),|n|&n.val),);}pub fn set(&mut self,index:isize,val:T::M){assert!(self.range.contains(&index));self.do_set(index,val,self.range.start,self.range.end,0);}fn do_fold(&self,start:isize,end:isize,l:isize,r:isize,now:u32)->T::M{if now==u32::MAX||l>=r{return T::id();}if start<=l&&r<=end{return T::op(&self.nodes[now as usize].val,&T::id());}if r<=start||end<=l{return T::id();}let mid=(r+l)/2;let lv=self.do_fold(start,end,l,mid,self.nodes[now as usize].left);let rv=self.do_fold(start,end,mid,r,self.nodes[now as usize].right);T::op(&lv,&rv)}pub fn fold(&self,range:impl RangeBounds<isize>)->T::M{let Range{start,end}=convert_range_isize(self.range.start,self.range.end,range);self.do_fold(start,end,self.range.start,self.range.end,0)}}}mod lazy{pub use crate::__cargo_equip::prelude::*;use std::{any::type_name,fmt::Debug,marker::PhantomData,mem::replace,ops::Bound,ops::{Add,Mul,Range,RangeBounds},};pub trait Monoid{type M;fn id()->Self::M;fn op(l:&Self::M,r:&Self::M)->Self::M;}pub trait MapMonoid{type M;type Act;fn e()->Self::M;fn op(l:&Self::M,r:&Self::M)->Self::M;fn id()->Self::Act;fn composite(l:&Self::Act,r:&Self::Act)->Self::Act;fn map(m:&Self::M,act:&Self::Act)->Self::M;#[doc=" If the `M` operation is not commutative (i.e., `MapMonoid::op` is not commutative), implement `reverse`."]fn reverse(m:&mut Self::M){let _=m;}}pub trait ZeroOne{fn zero()->Self;fn one()->Self;}macro_rules!impl_zero_one{($zero:expr,$one:expr,$($t:ty),*)=>{$(impl ZeroOne for$t{fn zero()->Self{$zero}fn one()->Self{$one}})*};}impl_zero_one!(0,1,u8,u16,u32,u64,u128,usize,i8,i16,i32,i64,i128,isize);impl_zero_one!(0.0,1.0,f32,f64);fn convert_range(len:usize,range:impl RangeBounds<usize>)->Range<usize>{let start=match range.start_bound(){Bound::Included(l)=>*l,Bound::Unbounded=>0,_=>unreachable!(),};let end=match range.end_bound(){Bound::Included(r)=>r+1,Bound::Excluded(r)=>*r,Bound::Unbounded=>len,};Range{start,end}}pub struct LazySegmentTree<M:MapMonoid>{n:usize,size:usize,log:usize,tree:Vec<M::M>,lazy:Vec<M::Act>,has_lazy:Vec<bool>,}impl<M:MapMonoid>LazySegmentTree<M>where M::M:Clone,M::Act:Clone,{pub fn new(size:usize)->Self{LazySegmentTree::from_vec(&vec![M::e();size])}pub fn from_vec(v:&[M::M])->Self{let n=v.len();let size=n.next_power_of_two();let log=size.trailing_zeros()as usize;let mut tree=vec![M::e();size*2];let lazy=vec![M::id();size*2];tree.iter_mut().skip(size).zip(v.iter().cloned()).for_each(|(t,w)|*t=w);for i in(1..size).rev(){tree[i]=M::op(&tree[i*2],&tree[i*2+1]);}Self{n,size,log,tree,lazy,has_lazy:vec![false;size*2],}}pub fn len(&self)->usize{self.n}pub fn is_empty(&self)->bool{self.len()==0}#[doc=" Set `val` to `index`-th element."]#[doc=""]#[doc=" # Panics"]#[doc=" - `index < self.len()` must be satisfied."]pub fn set(&mut self,idx:usize,val:M::M){assert!(idx<self.len());let idx=idx+self.size;for i in(1..self.log+1).rev(){self.push(idx>>i);}self.tree[idx]=val;for i in 1..=self.log{self.update(idx>>i);}}#[doc=" Get `index`-th element."]#[doc=""]#[doc=" # Panics"]#[doc=" - `index < self.len()` must be satisfied."]pub fn get(&mut self,idx:usize)->M::M{assert!(idx<self.len());let idx=idx+self.size;for i in(1..self.log+1).rev(){self.push(idx>>i);}self.tree[idx].clone()}#[doc=" Apply `M::op` to the elements within `range` and return its result."]#[doc=""]#[doc=" # Panics"]#[doc=" - The head of `range` must be smaller than or equal to the tail of `range`."]#[doc=" - `range` must not contain a range greater than `self.len()`."]pub fn fold(&mut self,range:impl RangeBounds<usize>)->M::M{let Range{start,end}=convert_range(self.len(),range);assert!(start<=end);assert!(end<=self.len());if start==end{return M::e();}let(mut l,mut r)=(start+self.size,end+self.size);for i in(1..self.log+1).rev(){if((l>>i)<<i)!=l{self.push(l>>i);}if((r>>i)<<i)!=r{self.push(r>>i);}}let(mut sml,mut smr)=(M::e(),M::e());while l<r{if l&1!=0{sml=M::op(&sml,&self.tree[l]);l+=1;}if r&1!=0{r-=1;smr=M::op(&self.tree[r],&smr);}l>>=1;r>>=1;}M::op(&sml,&smr)}pub fn all_prod(&self)->M::M{self.tree[1].clone()}#[doc=" Apply `val` to a point whose `index` is idx."]fn apply_one(&mut self,idx:usize,val:M::Act){assert!(idx<self.len());let idx=idx+self.size;for i in(1..self.log+1).rev(){self.push(idx>>i);}self.tree[idx]=M::map(&self.tree[idx],&val);for i in 1..=self.log{self.update(idx>>i);}}#[doc=" Apply `val` to the elements within `range`."]pub fn apply(&mut self,range:impl RangeBounds<usize>,val:M::Act){let Range{start,end}=convert_range(self.len(),range);assert!(start<=end);assert!(end<=self.len());if start==end{return;}if end-start==1{self.apply_one(start,val);return;}let(start,end)=(start+self.size,end+self.size);for i in(1..self.log+1).rev(){if((start>>i)<<i)!=start{self.push(start>>i);}if((end>>i)<<i)!=end{self.push((end-1)>>i);}}let(mut a,mut b)=(start,end);while a<b{if a&1!=0{self.all_apply(a,&val);a+=1;}if b&1!=0{b-=1;self.all_apply(b,&val);}a>>=1;b>>=1;}for i in 1..=self.log{if((start>>i)<<i)!=start{self.update(start>>i);}if((end>>i)<<i)!=end{self.update((end-1)>>i);}}}fn update(&mut self,idx:usize){self.tree[idx]=M::op(&self.tree[idx*2],&self.tree[idx*2+1]);}fn all_apply(&mut self,idx:usize,val:&M::Act){self.tree[idx]=M::map(&self.tree[idx],&val);if idx<self.size{self.lazy[idx]=M::composite(&val,&self.lazy[idx]);self.has_lazy[idx]=true;}}fn push(&mut self,idx:usize){if self.has_lazy[idx]{let val=replace(&mut self.lazy[idx],M::id());self.all_apply(idx*2,&val);self.all_apply(idx*2+1,&val);self.has_lazy[idx]=false;}}}impl<M:MapMonoid>Clone for LazySegmentTree<M>where M::M:Clone,M::Act:Clone,{fn clone(&self)->Self{Self{n:self.n,size:self.size,log:self.log,tree:self.tree.clone(),lazy:self.lazy.clone(),has_lazy:self.has_lazy.clone(),}}}impl<M:MapMonoid>Debug for LazySegmentTree<M>where M:MapMonoid,M::M:Debug,M::Act:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct(type_name::<Self>()).field("n",&self.n).field("size",&self.size).field("log",&self.log).field("tree",&self.tree).field("lazy",&self.lazy).finish()}}impl<M:MapMonoid>FromIterator<M::M>for LazySegmentTree<M>{fn from_iter<T:IntoIterator<Item=M::M>>(iter:T)->Self{let mut tree=iter.into_iter().collect::<Vec<_>>();let n=tree.len();let size=n.next_power_of_two();tree.resize_with(size*2,M::e);for i in 0..n{tree.swap(i,i+size);}let log=size.trailing_zeros()as usize;let lazy=(0..size*2).map(|_|M::id()).collect::<Vec<_>>();for i in(1..size).rev(){tree[i]=M::op(&tree[i*2],&tree[i*2+1]);}Self{n,size,log,tree,lazy,has_lazy:vec![false;size*2],}}}pub struct RangeAddRangeSumQuery<T>(PhantomData<fn()->T>);impl<T>RangeAddRangeSumQuery<T>where T:ZeroOne+Clone+Add<Output=T>+Mul<Output=T>,{pub fn new(size:usize)->LazySegmentTree<Self>{LazySegmentTree::from_vec(&vec![(T::zero(),T::one());size])}}impl<T>MapMonoid for RangeAddRangeSumQuery<T>where T:ZeroOne+Clone+Add<Output=T>+Mul<Output=T>,{type M=(T,T);type Act=T;fn e()->Self::M{(T::zero(),T::zero())}fn op(l:&Self::M,r:&Self::M)->Self::M{(l.0.clone()+r.0.clone(),l.1.clone()+r.1.clone())}fn id()->Self::Act{T::zero()}fn composite(l:&Self::Act,r:&Self::Act)->Self::Act{l.clone()+r.clone()}fn map(elem:&Self::M,act:&Self::Act)->Self::M{(elem.0.clone()+act.clone()*elem.1.clone(),elem.1.clone(),)}}pub struct RangeAddRangeMaximumQuery;impl RangeAddRangeMaximumQuery{pub fn new(size:usize)->LazySegmentTree<Self>{LazySegmentTree::from_vec(&vec![0;size])}}impl MapMonoid for RangeAddRangeMaximumQuery{type M=i64;type Act=i64;fn e()->Self::M{i64::MIN}fn op(l:&Self::M,r:&Self::M)->Self::M{*l.max(r)}fn id()->Self::Act{0}fn composite(l:&Self::Act,r:&Self::Act)->Self::Act{l+r}fn map(elem:&Self::M,act:&Self::Act)->Self::M{act+elem}}pub struct RangeAddRangeMinimumQuery;impl RangeAddRangeMinimumQuery{pub fn new(size:usize)->LazySegmentTree<Self>{LazySegmentTree::from_vec(&vec![0;size])}}impl MapMonoid for RangeAddRangeMinimumQuery{type M=i64;type Act=i64;fn e()->Self::M{i64::MAX}fn op(l:&Self::M,r:&Self::M)->Self::M{*l.min(r)}fn id()->Self::Act{0}fn composite(l:&Self::Act,r:&Self::Act)->Self::Act{l+r}fn map(elem:&Self::M,act:&Self::Act)->Self::M{act+elem}}pub struct RangeAffineRangeSum<T>(PhantomData<fn()->T>);impl<T>RangeAffineRangeSum<T>where T:ZeroOne+Clone+Add<Output=T>+Mul<Output=T>,{pub fn new(a:Vec<T>)->LazySegmentTree<Self>{let a=a.into_iter().map(|v|(v,T::one())).collect::<Vec<_>>();LazySegmentTree::from_vec(&a)}}impl<T>MapMonoid for RangeAffineRangeSum<T>where T:ZeroOne+Clone+Add<Output=T>+Mul<Output=T>,{type M=(T,T);type Act=(T,T);fn e()->Self::M{(T::zero(),T::zero())}fn op(l:&Self::M,r:&Self::M)->Self::M{(l.0.clone()+r.0.clone(),l.1.clone()+r.1.clone())}fn id()->Self::Act{(T::one(),T::zero())}fn composite(l:&Self::Act,r:&Self::Act)->Self::Act{(l.0.clone()*r.0.clone(),l.0.clone()*r.1.clone()+l.1.clone(),)}fn map(elem:&Self::M,act:&Self::Act)->Self::M{(act.0.clone()*elem.0.clone()+act.1.clone()*elem.1.clone(),elem.1.clone(),)}}pub struct RangeFlipRangeLongestTerm;impl RangeFlipRangeLongestTerm{pub fn new(v:&[bool])->LazySegmentTree<Self>{LazySegmentTree::from_vec(&v.iter().map(|&f|{let f=f as u32;(f,f,f,1,1-f,1-f,1-f)}).collect::<Vec<_>>(),)}}impl MapMonoid for RangeFlipRangeLongestTerm{type M=(u32,u32,u32,u32,u32,u32,u32);type Act=bool;fn e()->Self::M{(0,0,0,0,1,1,1)}fn op(l:&Self::M,r:&Self::M)->Self::M{let(rm,rl,rr,rt,rm0,rl0,rr0)=r;let(m,l,r,t,m0,l0,r0)=l;(*rm.max(m).max(&(r+rl)),if l==t{l+rl}else{*l},if rr==rt{rr+r}else{*rr},t+rt,*rm0.max(m0).max(&(r0+rl0)),if l0==t{l0+rl0}else{*l0},if rr0==rt{rr0+r0}else{*rr0},)}fn id()->Self::Act{false}fn composite(l:&Self::Act,r:&Self::Act)->Self::Act{l^r}fn map(elem:&Self::M,act:&Self::Act)->Self::M{if!act{return*elem;}let(m,l,r,t,m0,l0,r0)=elem;(*m0,*l0,*r0,*t,*m,*l,*r)}}}pub use dynamic::*;pub use lazy::*;use std::{any::type_name,fmt::Debug,ops::{Bound,Range,RangeBounds},};fn convert_range(len:usize,range:impl RangeBounds<usize>)->Range<usize>{let start=match range.start_bound(){Bound::Included(l)=>*l,Bound::Unbounded=>0,_=>unreachable!(),};let end=match range.end_bound(){Bound::Included(r)=>r+1,Bound::Excluded(r)=>*r,Bound::Unbounded=>len,};Range{start,end}}#[doc=" If the Link-Cut Tree does not require any operations, this type can be used as a dummy."]#[derive(Debug,Clone,Copy,Default,PartialEq,Eq)]pub struct DefaultZST;impl MapMonoid for DefaultZST{type M=();type Act=();fn e()->Self::M{}fn op(_:&Self::M,_:&Self::M)->Self::M{}fn map(_:&Self::M,_:&Self::Act)->Self::M{}fn id()->Self::Act{}fn composite(_:&Self::Act,_:&Self::Act)->Self::Act{}}pub trait ZeroOne{fn zero()->Self;fn one()->Self;}macro_rules!impl_zero_one{($zero:expr,$one:expr,$($t:ty),*)=>{$(impl ZeroOne for$t{fn zero()->Self{$zero}fn one()->Self{$one}})*};}impl_zero_one!(0,1,u8,u16,u32,u64,u128,usize,i8,i16,i32,i64,i128,isize);impl_zero_one!(0.0,1.0,f32,f64);fn convert_range_isize(min:isize,max:isize,range:impl RangeBounds<isize>)->Range<isize>{let l=match range.start_bound(){Bound::Included(l)=>*l,Bound::Unbounded=>min,Bound::Excluded(l)=>l-1,};let r=match range.end_bound(){Bound::Included(r)=>r+1,Bound::Excluded(r)=>*r,Bound::Unbounded=>max,};Range{start:l,end:r}}pub struct SegmentTree<T:Monoid>{t:Vec<T::M>,}impl<T:Monoid>SegmentTree<T>{#[doc=" Create new `SegmentTree` filled with `M::id`."]pub fn new(size:usize)->Self{Self{t:(0..size*2).map(|_|T::id()).collect(),}}pub fn from_vec(v:Vec<T::M>)->Self{let size=v.len();let mut t=(0..size).map(|_|T::id()).chain(v).collect::<Vec<_>>();for i in(1..size).rev(){t[i]=T::op(&t[i<<1],&t[(i<<1)|1]);}Self{t}}pub fn len(&self)->usize{self.t.len()>>1}pub fn is_empty(&self)->bool{self.len()==0}#[doc=" Get `index`-th element."]#[doc=""]#[doc=" # Panics"]#[doc=" - `index < self.len()` must be satisfied."]pub fn get(&self,index:usize)->&T::M{assert!(index<self.len());&self.t[index+self.len()]}#[doc=" Set `val` to `index`-th element."]#[doc=""]#[doc=" # Panics"]#[doc=" - `index < self.len()` must be satisfied."]pub fn set(&mut self,mut index:usize,val:T::M){assert!(index<self.len());index+=self.len();self.t[index]=val;while index>1{let(l,r)=(index.min(index^1),index.max(index^1));self.t[index>>1]=T::op(&self.t[l],&self.t[r]);index>>=1;}}#[doc=" Update `index`-th element by `f`."]#[doc=""]#[doc=" This method is equivalent to `self.set(index, f(self.get(index)))`."]#[doc=""]#[doc=" # Panics"]#[doc=" - `index < self.len()` must be satisfied."]pub fn update_by<F>(&mut self,index:usize,f:F)where F:Fn(&T::M)->T::M,{assert!(index<self.len());let new=f(&self.t[index+self.len()]);self.set(index,new);}#[doc=" Apply `M::op` to the elements within `range` and return its result."]#[doc=""]#[doc=" # Panics"]#[doc=" - The head of `range` must be smaller than or equal to the tail of `range`."]#[doc=" - `range` must not contain a range greater than `self.len()`."]#[doc=""]#[doc=" # Examples"]#[doc=" ```rust"]#[doc=" use ds::{SegmentTree, Monoid};"]#[doc=""]#[doc=" struct I32Sum;"]#[doc=" impl Monoid for I32Sum {"]#[doc="     type M = i32;"]#[doc="     fn id() -> i32 { 0 }"]#[doc="     fn op(l: &i32, r: &i32) -> i32 { l + r }"]#[doc=" }"]#[doc=""]#[doc=" let mut st = SegmentTree::<I32Sum>::from_vec(vec![0, 1, 2, 3]);"]#[doc=" assert_eq!(st.fold(1..3), 3);"]#[doc=" assert_eq!(st.fold(..), 6);"]#[doc=" st.set(2, 5);"]#[doc=" assert_eq!(st.fold(..), 9);"]#[doc=" // Panics !!! (range.start > range.end)"]#[doc=" // st.fold(3..1);"]#[doc=" // Panics !!! (index out of range)"]#[doc=" // st.fold(1..5);"]#[doc=" ```"]pub fn fold(&self,range:impl RangeBounds<usize>)->T::M{let Range{start,end}=convert_range(self.len(),range);assert!(start<=end);assert!(end<=self.len());let(mut l,mut r)=(start+self.len(),end+self.len());let(mut lf,mut rf)=(T::id(),T::id());while l<r{if l&1!=0{lf=T::op(&lf,&self.t[l]);l+=1;}if r&1!=0{rf=T::op(&self.t[r-1],&rf);}l>>=1;r>>=1;}T::op(&lf,&rf)}}impl<T:Monoid>Clone for SegmentTree<T>where T::M:Clone,{fn clone(&self)->Self{SegmentTree{t:self.t.clone()}}}impl<T:Monoid>Debug for SegmentTree<T>where T::M:Debug,{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct(type_name::<Self>()).field("t",&self.t).finish()}}impl<M:Monoid>FromIterator<M::M>for SegmentTree<M>{fn from_iter<T:IntoIterator<Item=M::M>>(iter:T)->Self{let mut t=iter.into_iter().collect::<Vec<M::M>>();let size=t.len();t.resize_with(size*2,M::id);for i in 0..size{t.swap(i,i+size);}for i in(1..size).rev(){t[i]=M::op(&t[i<<1],&t[(i<<1)|1]);}Self{t}}}#[derive(Debug,Clone)]pub struct Reversible<T:Monoid+Clone>{pub forward:T,pub reverse:T,}impl<T:Monoid+Clone>Reversible<T>{pub fn new(val:T)->Self{Self{forward:val.clone(),reverse:val,}}}impl<T:Monoid<M=T>+Clone>Monoid for Reversible<T>{type M=Self;fn id()->Self::M{Self{forward:T::id(),reverse:T::id(),}}fn op(l:&Self::M,r:&Self::M)->Self::M{Self{forward:T::op(&l.forward,&r.forward),reverse:T::op(&r.reverse,&l.reverse),}}}}pub mod utils{pub use crate::__cargo_equip::prelude::*;use std::{cmp::Ordering,collections::BTreeSet,fmt::{Debug,Display},io::{BufRead,BufReader,BufWriter,Stdin,Stdout,Write},ops::Bound::*,str::FromStr,};pub fn read_line_str_as_vec_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().collect()}pub fn read_line_binary_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().map(|x|x-b'0').collect()}pub fn read_vec_template<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->Vec<T>{line.clear();reader.read_line(line).unwrap();Vec::from_iter(line.split_whitespace().map(|x|match x.parse(){Ok(data)=>data,Err(_)=>default,}))}pub fn read_1_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->T{let v=read_vec_template(line,reader,default);v[0]}pub fn read_2_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T){let v=read_vec_template(line,reader,default);(v[0],v[1])}pub fn read_3_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2])}pub fn read_4_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2],v[3])}pub fn read_vec_string_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<String>{line.clear();reader.read_line(line).unwrap();line.split_whitespace().map(|x|x.to_string()).collect()}macro_rules!isOn{($S:expr,$b:expr)=>{($S&(1<<$b))>0};}macro_rules!turnOn{($S:ident,$b:expr)=>{$S|=(1<<$b)};($S:expr,$b:expr)=>{$S|(1<<$b)};}pub fn gcd(mut n:usize,mut m:usize)->usize{if n==0||m==0{return n+m;}while m!=0{if m<n{let t=m;m=n;n=t;}m=m%n;}n}pub fn true_distance_sq(a:(i64,i64),b:(i64,i64))->i64{let x=(a.0-b.0)*(a.0-b.0)+(a.1-b.1)*(a.1-b.1);return x;}pub fn lower_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err()}pub fn upper_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Less,ord=>ord,}).unwrap_err()}pub fn neighbors<T>(tree:&BTreeSet<T>,val:T)->(Option<&T>,Option<&T>)where T:Ord+Copy,{let mut before=tree.range((Unbounded,Excluded(val)));let mut after=tree.range((Excluded(val),Unbounded));(before.next_back(),after.next())}pub fn bin_search_template(l:usize,r:usize,f:&dyn Fn(usize)->bool)->usize{let mut l=l;let mut r=r;let mut ans=l;while l<=r{let mid=(l+r)/2;if f(mid){ans=mid;l=mid+1;}else{if mid==0{break;}r=mid-1;}}return ans;}pub fn ter_search_template(l:usize,r:usize,f:&dyn Fn(usize)->i32)->usize{let mut l=l;let mut r=r;while l<=r{if r-l<3{let mut ans=f(r);let mut pos=r;for i in l..r{if f(i)>ans{ans=f(i);pos=i;}}return pos;}let mid1=l+(r-l)/3;let mid2=r-(r-l)/3;let f1=f(mid1);let f2=f(mid2);if f1<f2{l=mid1;}else{r=mid2;}}return l;}pub fn two_pointer_template(a:&[i32],f:&dyn Fn(usize,usize)->bool){let mut l=0;let mut r=0;while l<a.len(){while r<a.len()&&f(l,r){r+=1;}if r==a.len(){break;}while!f(l,r){l+=1;}}}pub fn sliding_windows_d(s:&[u8],d:usize,f:&dyn Fn(usize)->usize){let mut start=0;let mut end=start+d-1;let mut contrib=0;(start..=end).for_each(|i|{contrib+=1;});while end+1<s.len(){contrib-=f(start);start+=1;end+=1;contrib+=f(end);}}pub fn next_permutation<T>(arr:&mut[T])->bool where T:std::cmp::Ord,{use std::cmp::Ordering;let last_ascending=match arr.windows(2).rposition(|w|w[0]<w[1]){Some(i)=>i,None=>{arr.reverse();return false;}};let swap_with=arr[last_ascending+1..].binary_search_by(|n|match arr[last_ascending].cmp(n){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err();arr.swap(last_ascending,last_ascending+swap_with);arr[last_ascending+1..].reverse();true}type V<T> =Vec<T>;type VV<T> =V<V<T>>;type Set<T> =BTreeSet<T>;type US=usize;type UU=(US,US);type UUU=(US,US,US);pub fn to_digit_array(a:u64)->V<US>{let mut ans:V<US> =V::new();let mut a=a;while a>0{ans.push((a%10)as usize);a/=10;}ans.reverse();ans}pub fn ceil_int(a:u64,b:u64)->u64{let mut r=a/b;if a%b!=0{r+=1;}r}pub fn sumxor(n:u64)->u64{let md=n%4;match md{0=>n,1=>1,2=>n+1,3=>0,_=>0,}}pub fn sumxor_range(l:u64,r:u64)->u64{if l==0{sumxor(r)}else{sumxor(l-1)^sumxor(r)}}pub fn mod_in_range(l:u64,r:u64,k:u64,m:u64)->(u64,u64,u64){let first_oc=if l<=k{k}else{k+(ceil_int(l-k,m))*m};if first_oc>r{return(0,0,0);}let last_oc=first_oc+((r-first_oc)/m)*m;let oc=((last_oc-k)-(first_oc-k))/m+1;(oc,first_oc,last_oc)}#[doc=" https://www.geeksforgeeks.org/sum-of-products-of-all-possible-k-size-subsets-of-the-given-array/"]#[doc=" In O(n*k)"]pub fn sum_of_product(arr:&Vec<US>,k:usize)->US{let n=arr.len();let mut dp:Vec<US> =vec![0;n+1];let mut cur_sum=0;for i in 1..=n{dp[i]=arr[i-1];cur_sum+=arr[i-1];}for _ in 2..=k{let mut temp_sum=0;for j in 1..=n{cur_sum-=dp[j];dp[j]=arr[j-1]*cur_sum;temp_sum+=dp[j];}cur_sum=temp_sum;}cur_sum}pub fn better_array_debug<T>(a:&V<T>)where T:Debug,{a.iter().enumerate().for_each(|(i,x)|println!("{i:4}: {x:?}"));}pub fn better_2_array_debug<T,D>(a:&V<T>,b:&V<D>)where T:Debug,D:Debug,{(0..a.len()).for_each(|i|{println!("{i:4}: {:?} -- {:4?}",a[i],b[i]);})}pub fn read_n_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<T>){let n=read_1_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,v)}pub fn read_n_m_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,US,V<T>){let(n,m)=read_2_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,m,v)}pub fn read_n_and_array_of_pair<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<(T,T)>){let n=read_1_number(line,reader,0usize);let mut v:V<(T,T)> =V::new();v.reserve(n);(0..n).for_each(|_|{let x=read_2_number(line,reader,default);v.push(x);});(n,v)}pub fn read_n_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,V<T>,V<T>){let n=read_1_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,a,b)}pub fn read_n_m_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,V<T>,V<T>){let(n,m)=read_2_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,a,b)}pub fn read_n_m_k_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,V<T>,V<T>){let(n,m,k)=read_3_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,k,a,b)}pub fn read_edge_list(m:usize,line:&mut String,reader:&mut BufReader<Stdin>)->V<(UU)>{let mut el:V<UU> =V::new();el.reserve(m);(0..m).for_each(|_|{let(u,v)=read_2_number(line,reader,0usize);el.push((u-1,v-1));});el}pub fn array_output<T>(a:&V<T>,out:&mut BufWriter<Stdout>)where T:Display,{a.iter().for_each(|x|{write!(out,"{x} ").unwrap();});writeln!(out).unwrap();}pub fn array_output_with_size<T>(a:&V<T>,out:&mut BufWriter<Stdout>)where T:Display,{write!(out,"{} ",a.len()).unwrap();a.iter().for_each(|x|{write!(out,"{x} ").unwrap();});writeln!(out).unwrap();}pub fn write_vertex_list_add1(a:&V<US>,out:&mut BufWriter<Stdout>){a.iter().for_each(|x|{write!(out,"{} ",x+1).unwrap();});writeln!(out).unwrap();}pub fn query(l:u64,r:u64,re:&mut BufReader<Stdin>,li:&mut String)->u64{println!("? {l} {r}");let ans=read_1_number(li,re,0u64);ans}}type VV<T> =Vec<Vec<T>>;type US=usize;fn solve(reader:&mut BufReader<Stdin>,line:&mut String,out:&mut BufWriter<StdoutLock>){let default=0usize;let t=utils::read_1_number(line,reader,default);(0..t).for_each(|_te|{});}fn main(){let mut reader=BufReader::new(stdin());let mut line=String::new();let mut out=BufWriter::new(stdout().lock());solve(&mut reader,&mut line,&mut out);}#[doc="  # Bundled libraries"]#[doc=" "]#[doc="  - `path+file:///usr/local/google/home/quocbaodo/Documents/rust_algo#cp_rust@0.1.0` published in **missing** licensed under **missing** as `crate::__cargo_equip::crates::cp_rust`"]#[allow(unused)]mod __cargo_equip{pub(crate)mod crates{pub mod cp_rust{}}pub(crate)mod macros{pub mod cp_rust{}}pub(crate)mod prelude{pub use crate::__cargo_equip::crates::*;}mod preludes{pub mod cp_rust{}}}