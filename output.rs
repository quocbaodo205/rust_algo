pub use __cargo_equip::prelude::*;use std::io::{stdin,stdout,BufReader,BufWriter,Stdin,StdoutLock,Write};pub mod utils{pub use crate::__cargo_equip::prelude::*;use std::{cmp::Ordering,collections::BTreeSet,fmt::Debug,io::{BufRead,BufReader,Stdin},ops::Bound::*,str::FromStr,};pub fn read_line_str_as_vec_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().collect()}pub fn read_line_binary_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().map(|x|x-b'0').collect()}pub fn read_vec_template<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->Vec<T>{line.clear();reader.read_line(line).unwrap();Vec::from_iter(line.split_whitespace().map(|x|match x.parse(){Ok(data)=>data,Err(_)=>default,}))}pub fn read_1_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->T{let v=read_vec_template(line,reader,default);v[0]}pub fn read_2_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T){let v=read_vec_template(line,reader,default);(v[0],v[1])}pub fn read_3_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2])}pub fn read_4_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2],v[3])}pub fn read_vec_string_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<String>{line.clear();reader.read_line(line).unwrap();line.split_whitespace().map(|x|x.to_string()).collect()}macro_rules!isOn{($S:expr,$b:expr)=>{($S&(1<<$b))>0};}macro_rules!turnOn{($S:ident,$b:expr)=>{$S|=(1<<$b)};($S:expr,$b:expr)=>{$S|(1<<$b)};}pub fn gcd(mut n:usize,mut m:usize)->usize{if n==0||m==0{return n+m;}while m!=0{if m<n{let t=m;m=n;n=t;}m=m%n;}n}pub fn true_distance_sq(a:(i64,i64),b:(i64,i64))->i64{let x=(a.0-b.0)*(a.0-b.0)+(a.1-b.1)*(a.1-b.1);return x;}pub fn lower_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err()}pub fn upper_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Less,ord=>ord,}).unwrap_err()}pub fn neighbors<T>(tree:&BTreeSet<T>,val:T)->(Option<&T>,Option<&T>)where T:Ord+Copy,{let mut before=tree.range((Unbounded,Excluded(val)));let mut after=tree.range((Excluded(val),Unbounded));(before.next_back(),after.next())}pub fn bin_search_template(l:usize,r:usize,f:&dyn Fn(usize)->bool)->usize{let mut l=l;let mut r=r;let mut ans=l;while l<=r{let mid=(l+r)/2;if f(mid){ans=mid;l=mid+1;}else{if mid==0{break;}r=mid-1;}}return ans;}#[doc=" Template for tenary search. f usually required a cache if it's hard to calculate."]pub fn ter_search_template(l:usize,r:usize,f:&dyn Fn(usize)->i32)->usize{let mut l=l;let mut r=r;while l<=r{if r-l<3{let mut ans=f(r);let mut pos=r;for i in l..r{if f(i)>ans{ans=f(i);pos=i;}}return pos;}let mid1=l+(r-l)/3;let mid2=r-(r-l)/3;let f1=f(mid1);let f2=f(mid2);if f1<f2{l=mid1;}else{r=mid2;}}return l;}pub fn two_pointer_template(a:&[i32],f:&dyn Fn(usize,usize)->bool){let mut l=0;let mut r=0;while l<a.len(){while r<a.len()&&f(l,r){r+=1;}if r==a.len(){break;}while!f(l,r){l+=1;}}}pub fn sliding_windows_d(s:&[u8],d:usize,f:&dyn Fn(usize)->usize){let mut start=0;let mut end=start+d-1;let mut contrib=0;(start..=end).for_each(|i|{contrib+=1;});while end+1<s.len(){contrib-=f(start);start+=1;end+=1;contrib+=f(end);}}#[doc=" Get first right / left pos that < a[i] using stack."]pub fn first_smaller_pos(a:&[usize])->(Vec<usize>,Vec<usize>){let n=a.len();let mut right_pos_smaller=vec![n;n];let mut st=Vec::<(usize,usize)>::new();for(i,&lcp_val)in a.iter().enumerate(){while let Some(&(last_pos,last_val))=st.last(){if last_val>lcp_val{right_pos_smaller[last_pos]=i;st.pop();}else{break;}}st.push((i,lcp_val));}let mut left_pos_smaller=vec![n;n];let mut st=Vec::<(usize,usize)>::new();for(i,&lcp_val)in a.iter().rev().enumerate(){while let Some(&(last_pos,last_val))=st.last(){if last_val>lcp_val{left_pos_smaller[last_pos]=i;st.pop();}else{break;}}st.push((i,lcp_val));}left_pos_smaller.reverse();left_pos_smaller.iter_mut().for_each(|x|*x=n-*x);(left_pos_smaller,right_pos_smaller)}pub fn next_permutation<T>(arr:&mut[T])->bool where T:std::cmp::Ord,{use std::cmp::Ordering;let last_ascending=match arr.windows(2).rposition(|w|w[0]<w[1]){Some(i)=>i,None=>{arr.reverse();return false;}};let swap_with=arr[last_ascending+1..].binary_search_by(|n|match arr[last_ascending].cmp(n){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err();arr.swap(last_ascending,last_ascending+swap_with);arr[last_ascending+1..].reverse();true}type V<T> =Vec<T>;type VV<T> =V<V<T>>;type Set<T> =BTreeSet<T>;type US=usize;type UU=(US,US);type UUU=(US,US,US);pub fn to_digit_array(a:u64)->V<US>{let mut ans:V<US> =V::new();let mut a=a;while a>0{ans.push((a%10)as usize);a/=10;}ans.reverse();ans}pub fn ceil_int(a:u64,b:u64)->u64{let mut r=a/b;if a%b!=0{r+=1;}r}pub fn sumxor(n:u64)->u64{let md=n%4;match md{0=>n,1=>1,2=>n+1,3=>0,_=>0,}}pub fn sumxor_range(l:u64,r:u64)->u64{if l==0{sumxor(r)}else{sumxor(l-1)^sumxor(r)}}pub fn mod_in_range(l:u64,r:u64,k:u64,m:u64)->(u64,u64,u64){let first_oc=if l<=k{k}else{k+(ceil_int(l-k,m))*m};if first_oc>r{return(0,0,0);}let last_oc=first_oc+((r-first_oc)/m)*m;let oc=((last_oc-k)-(first_oc-k))/m+1;(oc,first_oc,last_oc)}#[doc=" https://www.geeksforgeeks.org/sum-of-products-of-all-possible-k-size-subsets-of-the-given-array/"]#[doc=" In O(n*k)"]pub fn sum_of_product(arr:&Vec<US>,k:usize)->US{let n=arr.len();let mut dp:Vec<US> =vec![0;n+1];let mut cur_sum=0;for i in 1..=n{dp[i]=arr[i-1];cur_sum+=arr[i-1];}for _ in 2..=k{let mut temp_sum=0;for j in 1..=n{cur_sum-=dp[j];dp[j]=arr[j-1]*cur_sum;temp_sum+=dp[j];}cur_sum=temp_sum;}cur_sum}pub fn better_array_debug<T>(a:&V<T>)where T:Debug,{a.iter().enumerate().for_each(|(i,x)|println!("{i:4}: {x:?}"));}pub fn better_2_array_debug<T,D>(a:&V<T>,b:&V<D>)where T:Debug,D:Debug,{(0..a.len()).for_each(|i|{println!("{i:4}: {:?} -- {:4?}",a[i],b[i]);})}pub fn read_n_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<T>){let n=read_1_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,v)}pub fn read_n_m_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,US,V<T>){let(n,m)=read_2_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,m,v)}pub fn read_n_and_array_of_pair<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<(T,T)>){let n=read_1_number(line,reader,0usize);let mut v:V<(T,T)> =V::new();v.reserve(n);(0..n).for_each(|_|{let x=read_2_number(line,reader,default);v.push(x);});(n,v)}pub fn read_n_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,V<T>,V<T>){let n=read_1_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,a,b)}pub fn read_n_m_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,V<T>,V<T>){let(n,m)=read_2_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,a,b)}pub fn read_n_m_k_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,V<T>,V<T>){let(n,m,k)=read_3_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,k,a,b)}pub fn read_edge_list(m:usize,line:&mut String,reader:&mut BufReader<Stdin>)->V<(UU)>{let mut el:V<UU> =V::new();el.reserve(m);(0..m).for_each(|_|{let(u,v)=read_2_number(line,reader,0usize);el.push((u-1,v-1));});el}pub fn query(l:u64,r:u64,re:&mut BufReader<Stdin>,li:&mut String)->u64{println!("? {l} {r}");let ans=read_1_number(li,re,0u64);ans}}pub mod string_utils{pub use crate::__cargo_equip::prelude::*;use std::cmp::{max,min};#[allow(dead_code)]fn sliding_windows_d(s:&[u8],d:usize,f:&dyn Fn(usize)->usize){let mut start=0;let mut end=start+d-1;let mut contrib=0;(start..=end).for_each(|i|{contrib+=1;});while end+1<s.len(){contrib-=f(start);start+=1;end+=1;contrib+=f(end);}}#[allow(dead_code)]fn all_sub_str_template(s:&[u8],f:&dyn Fn(usize)->usize){(1..=s.len()).for_each(|d|{sliding_windows_d(s,d,f);});}#[allow(dead_code)]fn compress_01(s:&[u8])->Vec<(u8,usize)>{let mut cur=s[0];let mut count=1;let mut ans=Vec::new();(1..s.len()).for_each(|i|{if s[i]!=cur{ans.push((cur,count));count=0;}cur=s[i];count+=1;});ans.push((cur,count));ans}#[doc=" Search all (prefix, revsuffix) pairs efficiently."]#[doc=" Copy inner code and change accordingly."]pub fn search_prefix_revsuffix(p:&Vec<u8>){let pn=p.len();for i in(1..pn-1).rev(){let prefix=&p[0..i];if true{let suffix:Vec<u8> =p[i..].iter().rev().cloned().collect();}}let mut prefix:Vec<u8> =p.iter().cloned().collect();let mut suffix:Vec<u8> =Vec::new();suffix.reserve(pn);for i in 1..pn{suffix.push(prefix.pop().unwrap());}}pub fn unique_concaternation(a:&Vec<Vec<u8>>)->(Vec<u8>,Vec<usize>){let all_chars=['-','+','_','=','!','@','#','$','%','^','&','*','(',')','{','}','`','~','[',']',':',';',',','<','>','.','?','/','|','1','2','3','4','5','6','7','8','9','0',];let mut ans=Vec::<u8>::new();let mut all_length:usize=a.iter().map(|s|s.len()).sum();all_length+=a.len()-1;ans.reserve(all_length);let mut remap=vec![a.len();all_length];let mut cur_sep=0;for i in 0..a.len(){for&c in a[i].iter(){remap[ans.len()]=i;ans.push(c);}if i==a.len()-1{break;}ans.push(all_chars[cur_sep]as u8);cur_sep=(cur_sep+1)%all_chars.len();}(ans,remap)}pub fn print_string_with_index(s:&Vec<u8>){for(i,&c)in s.iter().enumerate(){println!("{i:2} : {}",c as char);}}#[allow(dead_code)]fn manacher_odd(st:&str)->Vec<usize>{let n=st.len();let mut s="$".to_owned();s.push_str(st);s.push('^');let s=s.as_bytes();let mut p=vec![0;n+2];let mut l:usize=1;let mut r:usize=1;(1..=n).for_each(|i|{p[i]=max(0,min(r-i,p[l+(r-i)]));while s[i-p[i]]==s[i+p[i]]{p[i]+=1;}if i+p[i]>r{l=i-p[i];r=i+p[i];}});p[1..p.len()-1].to_vec()}#[allow(dead_code)]fn manacher(st:&str)->(String,Vec<usize>){let mut t="".to_owned();st.chars().for_each(|c|{t.push('#');t.push(c);});t.push('#');let p=manacher_odd(&t);(t,p)}#[allow(dead_code)]fn is_palindrome(s:&[u8])->bool{let mut i=0;let mut j=s.len()-1;while i<j{if s[i]!=s[j]{return false;}i+=1;j-=1;}true}pub fn z_function(s:&[u8])->Vec<usize>{let n=s.len();let mut z=vec![0;n];let mut l=0;let mut r=0;(1..n).for_each(|i|{if i<r{z[i]=min(r-i,z[i-l]);}while(i+z[i]<n)&&(s[z[i]]==s[i+z[i]]){z[i]+=1;}if i+z[i]>r{l=i;r=i+z[i];}});z}#[doc=" Find all occurences of pattern p in a text t."]#[doc=" Both pattern and text is known beforehand."]#[allow(dead_code)]fn z_search(t:&[u8],p:&[u8]){let mut s:Vec<u8> =Vec::from_iter(p.iter().cloned());s.push(b'#');s.extend_from_slice(t);let z=z_function(&s);(0..t.len()).for_each(|i|{let k=z[i+p.len()+1];if k==p.len(){}});}#[allow(dead_code)]fn z_compress(s:&[u8])->usize{let z=z_function(&s);for i in 0..s.len(){if s.len()%(i+1)!=0{continue;}if i+1+z[i]==s.len(){return i+1;}}s.len()}use suffix_array::SuffixArray;use crate::utils;#[doc=" Find first different char positon"]pub fn first_mismatch(a:&[u8],b:&[u8])->usize{let mut i=0;while i<a.len()&&i<b.len()&&a[i]==b[i]{i+=1;}i}#[doc=" Find all occurences of pattern p in a text t."]#[doc=" Text is known beforehand, and can be kept by inputing the sa."]#[doc=" Return the first and last occ in sa. Complexity O(|p| log |t|) for binsearch and compare."]pub fn sa_search(t:&[u8],sa:&SuffixArray,p:&[u8])->(usize,usize){let mut l=0;let mut r=sa.suffix_array().len()-1;let pn=p.len();let mut first_sa_occ=r+1;while l<=r{let mid=(l+r)/2;let suffix=&t[sa.suffix_array()[mid]..min(t.len(),sa.suffix_array()[mid]+pn)];let mm=first_mismatch(suffix,p);if mm==pn{first_sa_occ=mid;if mid==0{break;}r=mid-1;}else{if mm==suffix.len(){l=mid+1;}else if suffix[mm]<p[mm]{l=mid+1;}else{if mid==0{break;}r=mid-1;}}}l=0;r=sa.suffix_array().len()-1;let mut last_sa_occ=r+1;while l<=r{let mid=(l+r)/2;let suffix=&t[sa.suffix_array()[mid]..min(t.len(),sa.suffix_array()[mid]+pn)];let mm=first_mismatch(suffix,p);if mm==pn{last_sa_occ=mid;l=mid+1;}else{if mm==suffix.len(){l=mid+1;}else if suffix[mm]<p[mm]{l=mid+1;}else{if mid==0{break;}r=mid-1;}}}(first_sa_occ,last_sa_occ)}#[doc=" Given an index i of the suffix array with a len, find the maximum range [l..=r]"]#[doc=" so that the lcp of the range >= len. Works in O(log n)"]pub fn get_range_with_lcp_i(sa:&SuffixArray,i:usize,len:usize)->(usize,usize){if sa.suffix_array().len()-sa.suffix_array()[i]<len{return(sa.suffix_array().len(),sa.suffix_array().len());}let mut l=i;let mut r=sa.suffix_array().len()-1;let mut right_bound=l;while l<=r{let mid=(l+r)/2;if sa.lcp(sa.suffix_array()[i],sa.suffix_array()[mid])>=len{right_bound=mid;l=mid+1;}else{if mid==0{break;}r=mid-1;}}let mut l=0;let mut r=i;let mut left_bound=r;while l<=r{let mid=(l+r)/2;if sa.lcp(sa.suffix_array()[i],sa.suffix_array()[mid])>=len{left_bound=mid;if mid==0{break;}r=mid-1;}else{l=mid+1;}}(left_bound,right_bound)}#[doc=" Template to explore all ranges with the LCP(l..=r) with all len"]#[doc=" Should be copy out and modify exploration function. Works in O(n) to explore all."]#[doc=" Do note that LCP always deal with atleast 2 strings, so need another run for 1 string."]pub fn all_range_with_lcp(sa:&SuffixArray){let(left_pos_smaller,right_pos_smaller)=utils::first_smaller_pos(sa.lcp_array());for(i,&lcp_val)in sa.lcp_array().iter().enumerate(){let r=right_pos_smaller[i];let l=left_pos_smaller[i];}}#[allow(dead_code)]fn longest_common_subsequence(s1:&[u8],s2:&[u8])->usize{let n=s1.len();let m=s2.len();let mut dp:Vec<Vec<usize>> =vec![vec![0;m+1];n+1];(0..n).for_each(|i|{(0..m).for_each(|j|{if s1[i]==s2[j]{dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+1);}else{dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);}});});dp[n][m]}#[allow(dead_code)]fn edit_distance(s1:&[u8],s2:&[u8])->usize{let n=s1.len();let m=s2.len();let mut dp:Vec<Vec<usize>> =vec![vec![0;m+1];n+1];(0..n).for_each(|i|dp[i+1][0]=i+1);(0..m).for_each(|i|dp[0][i+1]=i+1);(0..n).for_each(|i|{(0..m).for_each(|j|{dp[i+1][j+1]=min(dp[i][j+1]+1,min(dp[i+1][j]+1,dp[i][j]+if s1[i]==s2[j]{0}else{1},),);});});dp[n][m]}}use suffix_array::SuffixArray;type VV<T> =Vec<Vec<T>>;type US=usize;fn solve(reader:&mut BufReader<Stdin>,line:&mut String,out:&mut BufWriter<StdoutLock>){let default=0usize;let n=utils::read_1_number(line,reader,default);let s=utils::read_line_str_as_vec_template(line,reader);let rs:Vec<u8> =s.iter().rev().cloned().collect();let sa=SuffixArray::new(&rs);let f=utils::read_line_binary_template(line,reader);let rf:Vec<u8> =f.into_iter().rev().map(|x|if x==0{1}else{0}).collect();let mut sa_good_pos=vec![0;n];for i in 0..n{sa_good_pos[sa.suffix_array_inv()[i]]=rf[i];}let psum:Vec<u64> =sa_good_pos.iter().scan(0,|ssum,&x|{*ssum+=x as u64;Some(*ssum)}).collect();let mut ans:u64=n as u64-rf.iter().position(|&x|x==1).unwrap_or(n)as u64;let(left_pos_smaller,right_pos_smaller)=utils::first_smaller_pos(sa.lcp_array());for(i,&lcp_val)in sa.lcp_array().iter().enumerate(){let r=right_pos_smaller[i];let l=left_pos_smaller[i];let k=lcp_val as u64*(psum[r]-if l==0{0}else{psum[l-1]});ans=ans.max(k);}println!("{}",ans);}fn main(){let mut reader=BufReader::new(stdin());let mut line=String::new();let mut out=BufWriter::new(stdout().lock());solve(&mut reader,&mut line,&mut out);}#[doc="  # Bundled libraries"]#[doc=" "]#[doc="  - `path+file:///home/quocbaodo205/Documents/cp_rust#0.1.0`                                        published in **missing** licensed under **missing** as `crate::__cargo_equip::crates::cp_rust`"]#[doc="  - `path+file:///home/quocbaodo205/Documents/cprs/crates/algebra/numeric_traits#0.1.0`             published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::__numeric_traits_0_1_0`"]#[doc="  - `path+file:///home/quocbaodo205/Documents/cprs/crates/data_structure/range_minimum_query#0.1.0` published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::range_minimum_query`"]#[doc="  - `path+file:///home/quocbaodo205/Documents/cprs/crates/misc/as_half_open_range#0.1.0`            published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::__as_half_open_range_0_1_0`"]#[doc="  - `path+file:///home/quocbaodo205/Documents/cprs/crates/string/suffix_array#0.1.0`                published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::suffix_array`"]#[allow(unused)]mod __cargo_equip{pub(crate)mod crates{pub mod cp_rust{}pub mod __numeric_traits_0_1_0{pub mod inf{pub trait Inf:PartialOrd{fn inf()->Self;}pub trait NegInf:PartialOrd{fn neg_inf()->Self;}macro_rules!impl_inf{($($t:ty,$inf:expr,)*)=>{$(impl Inf for$t{fn inf()->Self{$inf}})*}}macro_rules!impl_neg_inf{($($t:ty,$neg_inf:expr,)*)=>{$(impl NegInf for$t{fn neg_inf()->Self{$neg_inf}})*}}impl_inf!{i32,1_001_000_000,u32,1_001_000_000,f32,1e10,i64,4_004_000_000_000_000_000,isize,4_004_000_000_000_000_000,u64,4_004_000_000_000_000_000,usize,4_004_000_000_000_000_000,f64,1e20,i128,8_008_000_000_000_000_000_000_000_000_000_000_000,u128,8_008_000_000_000_000_000_000_000_000_000_000_000,}impl_neg_inf!{i32,-1_001_000_000,u32,0,f32,-1e10,i64,-4_004_000_000_000_000_000,isize,-4_004_000_000_000_000_000,u64,0,usize,0,f64,-1e20,i128,-8_008_000_000_000_000_000_000_000_000_000_000_000,u128,0,}}pub use inf::*;pub mod zero_one{use std::ops::{Add,Mul};pub trait Zero:Sized+Add<Output=Self>{fn zero()->Self;}pub trait One:Sized+Mul<Output=Self>{fn one()->Self;}macro_rules!impl_zero_one{($($t:ty),*)=>{$(impl Zero for$t{fn zero()->Self{0 as$t}}impl One for$t{fn one()->Self{1 as$t}})*}}impl_zero_one!(u8,u16,u32,u64,u128,usize,i8,i16,i32,i64,i128,isize,f32,f64);}pub use zero_one::*;pub mod cast{pub trait Cast<T>{fn cast(self)->T;}macro_rules!impl_cast_2{($t1:ty,$($t2:ty),*)=>{$(impl Cast<$t2>for$t1{fn cast(self)->$t2{self as$t2}})*}}macro_rules!impl_cast_1{($($t:ty),*)=>{$(impl_cast_2!{$t,u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,usize,isize,f32,f64})*}}impl_cast_1!{u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,usize,isize,f32,f64}}pub use cast::*;pub mod numeric{use std::ops::{Add,AddAssign,Div,DivAssign,Mul,MulAssign,Sub,SubAssign};use crate::__cargo_equip::crates::__numeric_traits_0_1_0::zero_one;pub trait Numeric:Sized+Clone+Copy+std::fmt::Debug+std::fmt::Display+PartialEq+Add<Output=Self>+AddAssign+Sub<Output=Self>+SubAssign+Mul<Output=Self>+MulAssign+Div<Output=Self>+DivAssign+zero_one::Zero+zero_one::One{}macro_rules!impl_numeric{($($t:ty),*)=>{$(impl Numeric for$t{})*};}impl_numeric!{u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,usize,isize,f32,f64}}pub use numeric::*;pub mod integer{use std::ops::{BitAnd,BitAndAssign,BitOr,BitOrAssign,BitXor,BitXorAssign,Rem,RemAssign,Shl,ShlAssign,Shr,ShrAssign,};use crate::__cargo_equip::crates::__numeric_traits_0_1_0::Numeric;pub trait Integer:Numeric+Eq+Ord+std::hash::Hash+Rem<Output=Self>+RemAssign+BitXor<Output=Self>+BitXorAssign+BitAnd<Output=Self>+BitAndAssign+BitOr<Output=Self>+BitOrAssign+Shl<usize,Output=Self>+ShlAssign<usize>+Shr<usize,Output=Self>+ShrAssign<usize>{const MIN:Self;const MAX:Self;fn popcount(self)->usize;fn msb_index(self)->usize;fn lsb_index(self)->usize;fn msb(self)->Self;fn lsb(self)->Self;fn ceil_pow2(self)->Self;fn floor_pow2(self)->Self;fn ceil_log2(self)->usize;fn floor_log2(self)->usize;fn checked_msb_index(self)->Option<usize>;fn checked_lsb_index(self)->Option<usize>;fn checked_ceil_pow2(self)->Option<Self>;fn checked_floor_pow2(self)->Option<Self>;fn checked_ceil_log2(self)->Option<usize>;fn checked_floor_log2(self)->Option<usize>;fn floor_div(self,other:Self)->Self;fn ceil_div(self,other:Self)->Self;fn gcd(self,other:Self)->Self;fn lcm(self,other:Self)->Self;}macro_rules!impl_integer{($($t:ty),*)=>{$(impl Integer for$t{const MIN:Self=<$t>::MIN;const MAX:Self=<$t>::MAX;fn popcount(self)->usize{self.count_ones()as usize}fn msb_index(self)->usize{(<$t>::BITS-1-self.leading_zeros())as usize}fn lsb_index(self)->usize{self.trailing_zeros()as usize}fn msb(self)->Self{if self==0{0}else{1<<self.msb_index()}}fn lsb(self)->Self{self&self.wrapping_neg()}fn ceil_pow2(self)->Self{1<<self.ceil_log2()}fn floor_pow2(self)->Self{assert!(self>0);self.msb()}fn ceil_log2(self)->usize{assert!(self>0);(<$t>::BITS-(self-1).leading_zeros())as usize}fn floor_log2(self)->usize{assert!(self>0);self.msb_index()}fn checked_msb_index(self)->Option<usize>{if self==0{None}else{Some(self.msb_index())}}fn checked_lsb_index(self)->Option<usize>{if self==0{None}else{Some(self.lsb_index())}}fn checked_ceil_pow2(self)->Option<Self>{if self<=0{None}else{Some(self.ceil_pow2())}}fn checked_floor_pow2(self)->Option<Self>{if self<=0{None}else{Some(self.floor_pow2())}}fn checked_ceil_log2(self)->Option<usize>{if self<=0{None}else{Some(self.ceil_log2())}}fn checked_floor_log2(self)->Option<usize>{if self<=0{None}else{Some(self.floor_log2())}}#[allow(unused_comparisons)]fn floor_div(self,other:Self)->Self{self/other-if self^other<0&&self%other!=0{1}else{0}}#[allow(unused_comparisons)]fn ceil_div(self,other:Self)->Self{self/other+if self^other>=0&&self%other!=0{1}else{0}}#[allow(unused_comparisons)]fn gcd(self,other:Self)->Self{let mut x=if self<0{0-self}else{self};let mut y=if other<0{0-other}else{other};if x==0||y==0{return x|y;}let n=x.trailing_zeros();let m=y.trailing_zeros();x>>=n;y>>=m;while x!=y{if x>y{x-=y;x>>=x.trailing_zeros();}else{y-=x;y>>=y.trailing_zeros();}}x<<n.min(m)}fn lcm(self,other:Self)->Self{self/self.gcd(other)*other}})*};}impl_integer!{u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,usize,isize}}pub use integer::*;pub mod signed{use std::ops::Neg;pub trait Signed:Sized+Neg<Output=Self>{fn signum(self)->Self;}macro_rules!impl_signed_integer{($($t:ty),*)=>{$(impl Signed for$t{fn signum(self)->Self{match self{n if n>0=>1,0=>0,_=>-1,}}})*};}macro_rules!impl_signed_float{($($t:ty),*)=>{$(impl Signed for$t{fn signum(self)->Self{if self.is_nan(){self}else if self==0.0{0.0}else if self>0.0{1.0}else{-1.0}}})*};}impl_signed_integer!{i8,i16,i32,i64,i128,isize}impl_signed_float!{f32,f64}}pub use signed::*;pub trait Recip{fn recip(self)->Self;}impl Recip for f32{fn recip(self)->Self{self.recip()}}impl Recip for f64{fn recip(self)->Self{self.recip()}}}pub mod range_minimum_query{use crate::__cargo_equip::preludes::range_minimum_query::*;use std::ops::RangeBounds;use as_half_open_range::AsHalfOpenRange;use numeric_traits::Integer;const BLOCK_SIZE:usize=16;#[derive(Clone)]pub struct RangeMinimumQuery<T>{array:Vec<T>,large:Vec<Vec<u32>>,small:Vec<u16>,}impl<T>FromIterator<T>for RangeMinimumQuery<T>where T:Ord,{fn from_iter<I:IntoIterator<Item=T>>(iter:I)->Self{let xs=iter.into_iter().collect::<Vec<_>>();let n=xs.len();let block_n=n.floor_div(BLOCK_SIZE);let large=if let Some(lg_block_n)=block_n.checked_floor_log2(){let mut large=Vec::with_capacity(lg_block_n+1);let level=xs.chunks_exact(BLOCK_SIZE).enumerate().map(|(b,v)|{(v.iter().enumerate().min_by_key(|&(_,x)|x).map(|(i,_)|i).unwrap()+b*BLOCK_SIZE)as u32}).collect::<Vec<_>>();large.push(level);for i in 0..lg_block_n{let level=large[i].iter().zip(&large[i][1<<i..]).map(|(&a,&b)|{if xs[a as usize]<=xs[b as usize]{a}else{b}}).collect::<Vec<_>>();large.push(level);}large}else{vec![]};let mut small=Vec::with_capacity(n);let mut stack=Vec::<usize>::with_capacity(BLOCK_SIZE);let mut bit=0;for i in 0..n{if i%BLOCK_SIZE==0{stack.clear();bit=0;}while let Some(&j)=stack.last(){if xs[j]<=xs[i]{break;}bit&=!(1<<(j%BLOCK_SIZE));stack.pop();}stack.push(i);bit|=1<<(i%BLOCK_SIZE);small.push(bit);}Self{array:xs,large,small,}}}impl<T>RangeMinimumQuery<T>where T:Ord,{pub fn min(&self,range:impl RangeBounds<usize>)->Option<&T>{let(l,r)=range.as_half_open_range(0,self.array.len());if l==r{return None;}let bl=l.ceil_div(BLOCK_SIZE);let br=r.floor_div(BLOCK_SIZE);let mut res=None;if bl>br{let i=(self.small[r-1]&(!0<<(l%BLOCK_SIZE))).lsb_index();res=Self::merge(res,Some(&self.array[i+br*BLOCK_SIZE]));}else{if bl<br{let d=(br-bl).floor_log2();let level=&self.large[d];res=Self::merge(res,Some(&self.array[level[bl]as usize]));res=Self::merge(res,Some(&self.array[level[br-(1<<d)]as usize]));}if l%BLOCK_SIZE!=0{let i=(self.small[bl*BLOCK_SIZE-1]&(!0<<(l%BLOCK_SIZE))).lsb_index();res=Self::merge(res,Some(&self.array[i+(bl-1)*BLOCK_SIZE]));}if r%BLOCK_SIZE!=0{let i=self.small[r-1].lsb_index();res=Self::merge(res,Some(&self.array[i+br*BLOCK_SIZE]));}}res}fn merge<'a>(x:Option<&'a T>,y:Option<&'a T>)->Option<&'a T>{x.into_iter().chain(y.into_iter()).min()}}}pub mod __as_half_open_range_0_1_0{use crate::__cargo_equip::preludes::__as_half_open_range_0_1_0::*;use std::ops::{Bound,RangeBounds};use numeric_traits::Integer;pub trait AsHalfOpenRange<T>:RangeBounds<T>where T:Integer,{fn as_half_open_range(&self,l:T,r:T)->(T,T){let start=match self.start_bound(){Bound::Unbounded=>l,Bound::Included(&start)=>start,Bound::Excluded(&start)=>start+T::one(),};let end=match self.end_bound(){Bound::Unbounded=>r,Bound::Included(&end)=>end+T::one(),Bound::Excluded(&end)=>end,};assert!(l<=start&&start<=end&&end<=r);(start,end)}}impl<R,T>AsHalfOpenRange<T>for R where R:RangeBounds<T>,T:Integer,{}}pub mod suffix_array{use crate::__cargo_equip::preludes::suffix_array::*;use std::{cmp::Ordering,ops::RangeBounds};use as_half_open_range::AsHalfOpenRange;use numeric_traits::{Cast,Integer};use range_minimum_query::RangeMinimumQuery;#[derive(Clone)]pub struct SuffixArray{sa:Vec<usize>,sa_inv:Vec<usize>,lcp:Vec<usize>,rmq:RangeMinimumQuery<usize>,}impl SuffixArray{pub fn new<T>(s:&[T])->Self where T:Integer+Cast<usize>,{let n=s.len()+1;let mut s=if n==1{vec![0]}else{let min=*s.iter().min().unwrap();let max=*s.iter().max().unwrap();let m=(max-min).cast()+1;if m<=n{let mut encode=vec![0;m];for&x in s{encode[(x-min).cast()]=1;}for i in 1..m{encode[i]+=encode[i-1];}s.iter().map(|&x|encode[(x-min).cast()]).chain([0]).collect()}else{let mut z=s.to_vec();z.sort_unstable();z.dedup();s.iter().map(|&x|z.binary_search(&x).unwrap()+1).chain([0]).collect()}};let mut sa=Self::sa_is(&s);s.pop();sa.remove(0);let sa_inv=Self::inverse_permutation(&sa);let lcp=Self::build_lcp_array(&s,&sa,&sa_inv);let rmq=RangeMinimumQuery::from_iter(lcp.clone());Self{sa,sa_inv,lcp,rmq,}}pub fn suffix_array(&self)->&[usize]{&self.sa}pub fn suffix_array_inv(&self)->&[usize]{&self.sa_inv}pub fn lcp_array(&self)->&[usize]{&self.lcp}pub fn lcp(&self,i:usize,j:usize)->usize{let n=self.sa.len();if i==n||j==n{return 0;}if i==j{return n-i;}let mut i=self.sa_inv[i];let mut j=self.sa_inv[j];if i>j{std::mem::swap(&mut i,&mut j);}*self.rmq.min(i..j).unwrap()}pub fn compare(&self,s1_range:impl RangeBounds<usize>,s2_range:impl RangeBounds<usize>,)->Ordering{let(l1,r1)=s1_range.as_half_open_range(0,self.sa.len());let(l2,r2)=s2_range.as_half_open_range(0,self.sa.len());let n1=r1-l1;let n2=r2-l2;let lcp=self.lcp(l1,l2);match(n1==lcp,n2==lcp){(true,true)=>Ordering::Equal,(true,false)=>Ordering::Less,(false,true)=>Ordering::Greater,(false,false)=>self.sa_inv[l1+lcp].cmp(&self.sa_inv[l2+lcp]),}}fn sa_is(s:&[usize])->Vec<usize>{let n=s.len();let mut count=vec![0;n];for&x in s{count[x]+=1;}if count.iter().all(|&x|x==1){return Self::inverse_permutation(s);}let ls=Self::classify(s);let mut sa=vec![!0;n];let mut tail=Self::bucket_tail(&count);for i in(1..n).rev().filter(|&i|ls[i]==Type::S(true)){tail[s[i]]-=1;sa[tail[s[i]]]=i;}Self::induce(s,&mut sa,&count,&ls);let lms:Vec<_> =sa.into_iter().filter(|&i|i!=!0&&ls[i]==Type::S(true)).collect();let rs_sa=Self::sa_is(&Self::reduce(s,&lms,&ls));let lms:Vec<_> =(0..n).filter(|&i|ls[i]==Type::S(true)).collect();let mut tail=Self::bucket_tail(&count);let mut sa=vec![!0;n];for i in rs_sa.into_iter().rev(){let j=lms[i];tail[s[j]]-=1;sa[tail[s[j]]]=j;}Self::induce(s,&mut sa,&count,&ls);sa}fn inverse_permutation(s:&[usize])->Vec<usize>{let n=s.len();let mut res=vec![0;n];for i in 0..n{res[s[i]]=i;}res}fn classify(s:&[usize])->Vec<Type>{let n=s.len();let mut ls=vec![Type::S(false);n];for i in(0..n-1).rev(){ls[i]=match s[i].cmp(&s[i+1]){Ordering::Less=>Type::S(false),Ordering::Equal=>ls[i+1],Ordering::Greater=>Type::L,};}for i in 1..n{if let(Type::L,Type::S(_))=(ls[i-1],ls[i]){ls[i]=Type::S(true);}}ls}fn bucket_head(count:&[usize])->Vec<usize>{std::iter::once(&0).chain(&count[..count.len()-1]).scan(0,|acc,&x|{*acc+=x;Some(*acc)}).collect()}fn bucket_tail(count:&[usize])->Vec<usize>{count.iter().scan(0,|acc,&x|{*acc+=x;Some(*acc)}).collect()}fn induce(s:&[usize],sa:&mut[usize],count:&[usize],ls:&[Type]){let n=s.len();let mut head=Self::bucket_head(count);for i in 0..n{if sa[i]==0||sa[i]==!0||ls[sa[i]-1]!=Type::L{continue;}let j=sa[i]-1;sa[head[s[j]]]=j;head[s[j]]+=1;}let mut tail=Self::bucket_tail(count);for i in(1..n).rev(){if sa[i]==0||sa[i]==!0||ls[sa[i]-1]==Type::L{continue;}let j=sa[i]-1;tail[s[j]]-=1;sa[tail[s[j]]]=j;}}fn reduce(s:&[usize],lms:&[usize],ls:&[Type])->Vec<usize>{if lms.len()<=1{return vec![0;lms.len()];}let mut map=vec![0;s.len()];map[lms[1]]=1;let mut x=1;for i in 2..lms.len(){let equiv=s[lms[i]]==s[lms[i-1]]&&(lms[i]+1..).zip(lms[i-1]+1..).find_map(|(i0,i1)|{if(ls[i0],ls[i1])==(Type::S(true),Type::S(true)){Some(true)}else if ls[i0]!=ls[i1]||s[i0]!=s[i1]{Some(false)}else{None}}).unwrap();if!equiv{x+=1;}map[lms[i]]=x;}(0..s.len()).filter_map(|i|(ls[i]==Type::S(true)).then_some(map[i])).collect()}fn build_lcp_array(s:&[usize],sa:&[usize],sa_inv:&[usize])->Vec<usize>{let n=s.len();if n==0{return vec![];}let mut h=0usize;let mut lcp=vec![0;n-1];for i in 0..n-1{h=h.saturating_sub(1);if sa_inv[i]==0{continue;}let j=sa[sa_inv[i]-1];while i+h<n&&j+h<n{if s[i+h]!=s[j+h]{break;}h+=1;}lcp[sa_inv[i]-1]=h;}lcp}}#[derive(Clone,Copy,PartialEq,Eq)]enum Type{L,S(bool),}}}pub(crate)mod macros{pub mod cp_rust{}pub mod __numeric_traits_0_1_0{}pub mod range_minimum_query{}pub mod __as_half_open_range_0_1_0{}pub mod suffix_array{}}pub(crate)mod prelude{pub use crate::__cargo_equip::crates::*;}mod preludes{pub mod cp_rust{pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{range_minimum_query,suffix_array};}pub mod __numeric_traits_0_1_0{}pub mod range_minimum_query{pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{__as_half_open_range_0_1_0 as as_half_open_range,__numeric_traits_0_1_0 as numeric_traits};}pub mod __as_half_open_range_0_1_0{pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::__numeric_traits_0_1_0 as numeric_traits;}pub mod suffix_array{pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{__as_half_open_range_0_1_0 as as_half_open_range,__numeric_traits_0_1_0 as numeric_traits,range_minimum_query};}}}