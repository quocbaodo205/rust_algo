pub use __cargo_equip::prelude::*;use std::{collections::{BTreeMap,BTreeSet},io::{stdin,stdout,BufReader,BufWriter,Stdin,StdoutLock,Write},};pub mod utils{pub use crate::__cargo_equip::prelude::*;use std::{cmp::Ordering,collections::BTreeSet,fmt::Debug,io::{BufRead,BufReader,Stdin},ops::Bound::*,str::FromStr,};pub fn read_line_str_as_vec_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().collect()}pub fn read_line_binary_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().map(|x|x-b'0').collect()}pub fn read_vec_template<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->Vec<T>{line.clear();reader.read_line(line).unwrap();Vec::from_iter(line.split_whitespace().map(|x|match x.parse(){Ok(data)=>data,Err(_)=>default,}))}pub fn read_1_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->T{let v=read_vec_template(line,reader,default);v[0]}pub fn read_2_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T){let v=read_vec_template(line,reader,default);(v[0],v[1])}pub fn read_3_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2])}pub fn read_4_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2],v[3])}pub fn read_vec_string_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<String>{line.clear();reader.read_line(line).unwrap();line.split_whitespace().map(|x|x.to_string()).collect()}macro_rules!isOn{($S:expr,$b:expr)=>{($S&(1<<$b))>0};}macro_rules!turnOn{($S:ident,$b:expr)=>{$S|=(1<<$b)};($S:expr,$b:expr)=>{$S|(1<<$b)};}pub fn gcd(mut n:usize,mut m:usize)->usize{if n==0||m==0{return n+m;}while m!=0{if m<n{let t=m;m=n;n=t;}m=m%n;}n}pub fn true_distance_sq(a:(i64,i64),b:(i64,i64))->i64{let x=(a.0-b.0)*(a.0-b.0)+(a.1-b.1)*(a.1-b.1);return x;}pub fn lower_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err()}pub fn upper_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Less,ord=>ord,}).unwrap_err()}pub fn neighbors<T>(tree:&BTreeSet<T>,val:T)->(Option<&T>,Option<&T>)where T:Ord+Copy,{let mut before=tree.range((Unbounded,Excluded(val)));let mut after=tree.range((Excluded(val),Unbounded));(before.next_back(),after.next())}pub fn bin_search_template(l:usize,r:usize,f:&dyn Fn(usize)->bool)->usize{let mut l=l;let mut r=r;let mut ans=l;while l<=r{let mid=(l+r)/2;if f(mid){ans=mid;l=mid+1;}else{if mid==0{break;}r=mid-1;}}return ans;}#[doc=" Template for tenary search. f usually required a cache if it's hard to calculate."]pub fn ter_search_template(l:usize,r:usize,f:&dyn Fn(usize)->i32)->usize{let mut l=l;let mut r=r;while l<=r{if r-l<3{let mut ans=f(r);let mut pos=r;for i in l..r{if f(i)>ans{ans=f(i);pos=i;}}return pos;}let mid1=l+(r-l)/3;let mid2=r-(r-l)/3;let f1=f(mid1);let f2=f(mid2);if f1<f2{l=mid1;}else{r=mid2;}}return l;}pub fn two_pointer_template(a:&[i32],f:&dyn Fn(usize,usize)->bool){let mut l=0;let mut r=0;while l<a.len(){while r<a.len()&&f(l,r){r+=1;}if r==a.len(){break;}while!f(l,r){l+=1;}}}pub fn sliding_windows_d(s:&[u8],d:usize,f:&dyn Fn(usize)->usize){let mut start=0;let mut end=start+d-1;let mut contrib=0;(start..=end).for_each(|i|{contrib+=1;});while end+1<s.len(){contrib-=f(start);start+=1;end+=1;contrib+=f(end);}}#[doc=" Get first right / left pos that < a[i] using stack."]pub fn first_smaller_pos(a:&[usize])->(Vec<usize>,Vec<usize>){let n=a.len();let mut right_pos_smaller=vec![n;n];let mut st=Vec::<(usize,usize)>::new();for(i,&lcp_val)in a.iter().enumerate(){while let Some(&(last_pos,last_val))=st.last(){if last_val>lcp_val{right_pos_smaller[last_pos]=i;st.pop();}else{break;}}st.push((i,lcp_val));}let mut left_pos_smaller=vec![n;n];let mut st=Vec::<(usize,usize)>::new();for(i,&lcp_val)in a.iter().rev().enumerate(){while let Some(&(last_pos,last_val))=st.last(){if last_val>lcp_val{left_pos_smaller[last_pos]=i;st.pop();}else{break;}}st.push((i,lcp_val));}left_pos_smaller.reverse();left_pos_smaller.iter_mut().for_each(|x|*x=n-*x);(left_pos_smaller,right_pos_smaller)}pub fn next_permutation<T>(arr:&mut[T])->bool where T:std::cmp::Ord,{use std::cmp::Ordering;let last_ascending=match arr.windows(2).rposition(|w|w[0]<w[1]){Some(i)=>i,None=>{arr.reverse();return false;}};let swap_with=arr[last_ascending+1..].binary_search_by(|n|match arr[last_ascending].cmp(n){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err();arr.swap(last_ascending,last_ascending+swap_with);arr[last_ascending+1..].reverse();true}type V<T> =Vec<T>;type VV<T> =V<V<T>>;type Set<T> =BTreeSet<T>;type US=usize;type UU=(US,US);type UUU=(US,US,US);pub fn to_digit_array(a:u64)->V<US>{let mut ans:V<US> =V::new();let mut a=a;while a>0{ans.push((a%10)as usize);a/=10;}ans.reverse();ans}pub fn ceil_int(a:u64,b:u64)->u64{let mut r=a/b;if a%b!=0{r+=1;}r}pub fn sumxor(n:u64)->u64{let md=n%4;match md{0=>n,1=>1,2=>n+1,3=>0,_=>0,}}pub fn sumxor_range(l:u64,r:u64)->u64{if l==0{sumxor(r)}else{sumxor(l-1)^sumxor(r)}}pub fn mod_in_range(l:u64,r:u64,k:u64,m:u64)->(u64,u64,u64){let first_oc=if l<=k{k}else{k+(ceil_int(l-k,m))*m};if first_oc>r{return(0,0,0);}let last_oc=first_oc+((r-first_oc)/m)*m;let oc=((last_oc-k)-(first_oc-k))/m+1;(oc,first_oc,last_oc)}#[doc=" https://www.geeksforgeeks.org/sum-of-products-of-all-possible-k-size-subsets-of-the-given-array/"]#[doc=" In O(n*k)"]pub fn sum_of_product(arr:&Vec<US>,k:usize)->US{let n=arr.len();let mut dp:Vec<US> =vec![0;n+1];let mut cur_sum=0;for i in 1..=n{dp[i]=arr[i-1];cur_sum+=arr[i-1];}for _ in 2..=k{let mut temp_sum=0;for j in 1..=n{cur_sum-=dp[j];dp[j]=arr[j-1]*cur_sum;temp_sum+=dp[j];}cur_sum=temp_sum;}cur_sum}pub fn better_array_debug<T>(a:&V<T>)where T:Debug,{a.iter().enumerate().for_each(|(i,x)|println!("{i:4}: {x:?}"));}pub fn better_2_array_debug<T,D>(a:&V<T>,b:&V<D>)where T:Debug,D:Debug,{(0..a.len()).for_each(|i|{println!("{i:4}: {:?} -- {:4?}",a[i],b[i]);})}pub fn read_n_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<T>){let n=read_1_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,v)}pub fn read_n_m_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,US,V<T>){let(n,m)=read_2_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,m,v)}pub fn read_n_and_array_of_pair<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<(T,T)>){let n=read_1_number(line,reader,0usize);let mut v:V<(T,T)> =V::new();v.reserve(n);(0..n).for_each(|_|{let x=read_2_number(line,reader,default);v.push(x);});(n,v)}pub fn read_n_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,V<T>,V<T>){let n=read_1_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,a,b)}pub fn read_n_m_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,V<T>,V<T>){let(n,m)=read_2_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,a,b)}pub fn read_n_m_k_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,V<T>,V<T>){let(n,m,k)=read_3_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,k,a,b)}pub fn read_edge_list(m:usize,line:&mut String,reader:&mut BufReader<Stdin>)->V<(UU)>{let mut el:V<UU> =V::new();el.reserve(m);(0..m).for_each(|_|{let(u,v)=read_2_number(line,reader,0usize);el.push((u-1,v-1));});el}pub fn query(l:u64,r:u64,re:&mut BufReader<Stdin>,li:&mut String)->u64{println!("? {l} {r}");let ans=read_1_number(li,re,0u64);ans}}pub mod mod_structure{pub use crate::__cargo_equip::prelude::*;#[doc=" Deal with [a + k*d] repeating points, ranges and other modulo collision structure."]use std::collections::{BTreeMap,BTreeSet};use std::ops::Bound::*;use crate::utils;#[doc=" Given a repeating range of [x..x+d] % k, find if a point s is in this range."]#[doc=" Often you are given a lot of repeating ranges [x1..x1+d]... but a constant d and k."]#[doc=" r = s % k => r-d <= x <= r."]#[doc=" Given r, if any x satisfy this eq, then it's good. You can find this via range sum."]pub fn check_in_repeating_ranges(all_x:&Vec<usize>,d:usize,k:usize,s:usize)->bool{let mut p=vec![0;k];for&x in all_x.iter(){p[x%k]+=1;}let psum:Vec<usize> =p.iter().scan(0,|ssum,&px|{*ssum+=px;Some(*ssum)}).collect();let r=s%k;let range_sum=psum[r]-if r>d{psum[r-d-1]}else{0};range_sum>0}#[doc=" Given some points on the number line with a periodic property: p[i] change state for a moment at every t === d[i] mod k point in time."]#[doc=" Find the closest collision: If we're at time t, point x, and moving in the positive direction at a rate 1,"]#[doc=" find the next point p[i] so that t + (p[i] - x) === d[i] mod k."]#[doc=" We will assume p[i] is sorted inc."]pub fn positive_move_collision(p:&Vec<u64>,k:u64,x:u64,t:u64,positive_groups:&BTreeMap<u64,Vec<usize>>,)->Option<usize>{let next_i=utils::upper_bound_pos(&p,x);if next_i==p.len(){return None;}let xt_positive_group=(k+(t%k)-(x%k))%k;if let Some(v)=positive_groups.get(&xt_positive_group){let v_pos=utils::lower_bound_pos(v,next_i);if v_pos<v.len(){return Some(v[v_pos]);}}None}#[doc=" Same as above but with negative direction movement."]pub fn negative_move_collision(p:&Vec<u64>,k:u64,x:u64,t:u64,negative_groups:&BTreeMap<u64,Vec<usize>>,)->Option<usize>{let prev_i=utils::lower_bound_pos(&p,x);if prev_i==0{return None;}let prev_i=prev_i-1;let xt_negative_group=((t%k)+(x%k))%k;if let Some(v)=negative_groups.get(&xt_negative_group){let v_pos=utils::lower_bound_pos(v,prev_i);if v_pos<v.len(){if v[v_pos]==prev_i{return Some(prev_i);}if v_pos>0{return Some(v[v_pos-1]);}}}None}}type VV<T> =Vec<Vec<T>>;type US=usize;fn solve(reader:&mut BufReader<Stdin>,line:&mut String,out:&mut BufWriter<StdoutLock>){let default=0usize;let t=utils::read_1_number(line,reader,default);(0..t).for_each(|_te|{let(n,k)=utils::read_2_number(line,reader,0u64);let n=n as usize;let p=utils::read_vec_template(line,reader,0u64);let d=utils::read_vec_template(line,reader,0u64);let mut positive_groups=BTreeMap::<u64,Vec<usize>>::new();for i in 0..p.len(){let g=(k+(d[i]%k)-(p[i]%k))%k;positive_groups.entry(g).and_modify(|v|(*v).push(i)).or_insert(vec![i]);}let mut negative_groups=BTreeMap::<u64,Vec<usize>>::new();for i in 0..p.len(){let g=((d[i]%k)+(p[i]%k))%k;negative_groups.entry(g).and_modify(|v|(*v).push(i)).or_insert(vec![i]);}let _=utils::read_1_number(line,reader,default);let qa=utils::read_vec_template(line,reader,0u64);let mut known_loop:BTreeSet<(u64,bool)> =BTreeSet::new();let mut known_not_loop:BTreeSet<(u64,bool)> =BTreeSet::new();for&st in qa.iter(){let mut cur_time=0;let mut cur_coord=st;let mut dir=true;let lb=utils::lower_bound_pos(&p,cur_coord);if lb<p.len()&&p[lb]==cur_coord&&d[lb]==0{dir=false;}let mut seen:BTreeSet<(u64,bool)> =BTreeSet::new();let mut is_loop=true;loop{if dir{let next_turn_pos=mod_structure::positive_move_collision(&p,k,cur_coord,cur_time,&positive_groups,);if let Some(pos)=next_turn_pos{let next_turn_coord=p[pos];cur_time=(cur_time+(next_turn_coord-cur_coord))%k;cur_coord=next_turn_coord;dir=!dir;if seen.contains(&(cur_coord,dir)){break;}if known_loop.contains(&(cur_coord,dir)){break;}if known_not_loop.contains(&(cur_coord,dir)){is_loop=false;break;}seen.insert((cur_coord,dir));}else{is_loop=false;break;}}else{let prev_turn_pos=mod_structure::negative_move_collision(&p,k,cur_coord,cur_time,&negative_groups,);if let Some(pos)=prev_turn_pos{let prev_turn_coord=p[pos];cur_time=(cur_time+(cur_coord-prev_turn_coord))%k;cur_coord=prev_turn_coord;dir=!dir;if seen.contains(&(cur_coord,dir)){break;}if known_loop.contains(&(cur_coord,dir)){break;}if known_not_loop.contains(&(cur_coord,dir)){is_loop=false;break;}seen.insert((cur_coord,dir));}else{is_loop=false;break;}}}if is_loop{writeln!(out,"NO").unwrap();for&xx in seen.iter(){known_loop.insert(xx);}}else{writeln!(out,"YES").unwrap();for&xx in seen.iter(){known_not_loop.insert(xx);}}}});}fn main(){let mut reader=BufReader::new(stdin());let mut line=String::new();let mut out=BufWriter::new(stdout().lock());solve(&mut reader,&mut line,&mut out);}#[doc="  # Bundled libraries"]#[doc=" "]#[doc="  - `path+file:///usr/local/google/home/quocbaodo/Documents/rust_algo#cp_rust@0.1.0` published in **missing** licensed under **missing** as `crate::__cargo_equip::crates::cp_rust`"]#[allow(unused)]mod __cargo_equip{pub(crate)mod crates{pub mod cp_rust{}}pub(crate)mod macros{pub mod cp_rust{}}pub(crate)mod prelude{pub use crate::__cargo_equip::crates::*;}mod preludes{pub mod cp_rust{}}}