pub use __cargo_equip::prelude::*;use std::{collections::BTreeSet,io::{stdin,stdout,BufReader,BufWriter,Stdin,StdoutLock,Write},};pub mod rng{#![doc=" Pseudorandom number generators (PRNGs)."]pub use crate::__cargo_equip::prelude::*;#[doc=" A simple and efficient random number generator."]pub type SmallRng=Xoshiro256PlusPlus;#[doc=" A xoshiro256++ random number generator."]#[doc=""]#[doc=" This is a simplified version of the `SmallRng` implementation from the"]#[doc=" excellent `rand` crate, keeping only essential features."]#[doc=""]#[doc=" The xoshiro256++ algorithm is not suitable for cryptographic purposes, but"]#[doc=" is very fast and has excellent statistical properties."]#[doc=""]#[doc=" * Source: [Docs.rs](https://docs.rs/rand/0.8.4/src/rand/rngs/xoshiro256plusplus.rs.html)"]#[doc=" * Theory: [Xorshift - Wikipedia](https://en.wikipedia.org/wiki/Xorshift)"]#[derive(Debug,Clone,PartialEq,Eq)]pub struct Xoshiro256PlusPlus{s:[u64;4],}impl Xoshiro256PlusPlus{#[doc=" Construct a new RNG from a 64-bit seed."]pub fn new(mut state:u64)->Self{const PHI:u64=0x9e3779b97f4a7c15;let mut seed=<[u64;4]>::default();for chunk in&mut seed{state=state.wrapping_add(PHI);let mut z=state;z=(z^(z>>30)).wrapping_mul(0xbf58476d1ce4e5b9);z=(z^(z>>27)).wrapping_mul(0x94d049bb133111eb);z=z^(z>>31);*chunk=z;}Self{s:seed}}#[doc=" Generate a random `u32`."]#[inline]pub fn next_u32(&mut self)->u32{(self.next_u64()>>32)as u32}#[doc=" Generate a random `u64`."]#[inline]pub fn next_u64(&mut self)->u64{let result_plusplus=self.s[0].wrapping_add(self.s[3]).rotate_left(23).wrapping_add(self.s[0]);let t=self.s[1]<<17;self.s[2]^=self.s[0];self.s[3]^=self.s[1];self.s[1]^=self.s[2];self.s[0]^=self.s[3];self.s[2]^=t;self.s[3]=self.s[3].rotate_left(45);result_plusplus}}#[cfg(test)]mod tests{pub use crate::__cargo_equip::prelude::*;use super::*;#[test]fn test_xoshiro256plusplus(){let mut rng=Xoshiro256PlusPlus::new(42);assert_eq!(rng.next_u64(),15021278609987233951);assert_eq!(rng.next_u64(),5881210131331364753);assert_eq!(rng.next_u64(),18149643915985481100);assert_eq!(rng.next_u64(),12933668939759105464);assert_eq!(rng.next_u64(),14637574242682825331);assert_eq!(rng.next_u64(),10848501901068131965);assert_eq!(rng.next_u64(),2312344417745909078);assert_eq!(rng.next_u64(),11162538943635311430);}#[test]fn reference(){let mut rng=Xoshiro256PlusPlus{s:[1,2,3,4]};let expected=[41943041,58720359,3588806011781223,3591011842654386,9228616714210784205,9973669472204895162,14011001112246962877,12406186145184390807,15849039046786891736,10450023813501588000,];for&e in&expected{assert_eq!(rng.next_u64(),e);}}}}use rng::SmallRng;pub mod utils{pub use crate::__cargo_equip::prelude::*;use std::{cmp::Ordering,collections::BTreeSet,fmt::Debug,io::{BufRead,BufReader,Stdin},ops::Bound::*,str::FromStr,};pub fn read_line_str_as_vec_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().collect()}pub fn read_line_binary_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<u8>{line.clear();reader.read_line(line).unwrap();line.trim().as_bytes().iter().cloned().map(|x|x-b'0').collect()}pub fn read_vec_template<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->Vec<T>{line.clear();reader.read_line(line).unwrap();Vec::from_iter(line.split_whitespace().map(|x|match x.parse(){Ok(data)=>data,Err(_)=>default,}))}pub fn read_1_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->T{let v=read_vec_template(line,reader,default);v[0]}pub fn read_2_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T){let v=read_vec_template(line,reader,default);(v[0],v[1])}pub fn read_3_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2])}pub fn read_4_number<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,T){let v=read_vec_template(line,reader,default);(v[0],v[1],v[2],v[3])}pub fn read_vec_string_template(line:&mut String,reader:&mut BufReader<Stdin>)->Vec<String>{line.clear();reader.read_line(line).unwrap();line.split_whitespace().map(|x|x.to_string()).collect()}macro_rules!isOn{($S:expr,$b:expr)=>{($S&(1<<$b))>0};}macro_rules!turnOn{($S:ident,$b:expr)=>{$S|=(1<<$b)};($S:expr,$b:expr)=>{$S|(1<<$b)};}pub fn gcd(mut n:usize,mut m:usize)->usize{if n==0||m==0{return n+m;}while m!=0{if m<n{let t=m;m=n;n=t;}m=m%n;}n}pub fn true_distance_sq(a:(i64,i64),b:(i64,i64))->i64{let x=(a.0-b.0)*(a.0-b.0)+(a.1-b.1)*(a.1-b.1);return x;}pub fn lower_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err()}pub fn upper_bound_pos<T:Ord+PartialOrd>(a:&Vec<T>,search_value:T)->usize{a.binary_search_by(|e|match e.cmp(&search_value){Ordering::Equal=>Ordering::Less,ord=>ord,}).unwrap_err()}pub fn neighbors<T>(tree:&BTreeSet<T>,val:T)->(Option<&T>,Option<&T>)where T:Ord+Copy,{let mut before=tree.range((Unbounded,Excluded(val)));let mut after=tree.range((Excluded(val),Unbounded));(before.next_back(),after.next())}pub fn bin_search_template(l:usize,r:usize,f:&dyn Fn(usize)->bool)->usize{let mut l=l;let mut r=r;let mut ans=l;while l<=r{let mid=(l+r)/2;if f(mid){ans=mid;l=mid+1;}else{if mid==0{break;}r=mid-1;}}return ans;}pub fn ter_search_template(l:usize,r:usize,f:&dyn Fn(usize)->i32)->usize{let mut l=l;let mut r=r;while l<=r{if r-l<3{let mut ans=f(r);let mut pos=r;for i in l..r{if f(i)>ans{ans=f(i);pos=i;}}return pos;}let mid1=l+(r-l)/3;let mid2=r-(r-l)/3;let f1=f(mid1);let f2=f(mid2);if f1<f2{l=mid1;}else{r=mid2;}}return l;}pub fn two_pointer_template(a:&[i32],f:&dyn Fn(usize,usize)->bool){let mut l=0;let mut r=0;while l<a.len(){while r<a.len()&&f(l,r){r+=1;}if r==a.len(){break;}while!f(l,r){l+=1;}}}pub fn sliding_windows_d(s:&[u8],d:usize,f:&dyn Fn(usize)->usize){let mut start=0;let mut end=start+d-1;let mut contrib=0;(start..=end).for_each(|i|{contrib+=1;});while end+1<s.len(){contrib-=f(start);start+=1;end+=1;contrib+=f(end);}}pub fn next_permutation<T>(arr:&mut[T])->bool where T:std::cmp::Ord,{use std::cmp::Ordering;let last_ascending=match arr.windows(2).rposition(|w|w[0]<w[1]){Some(i)=>i,None=>{arr.reverse();return false;}};let swap_with=arr[last_ascending+1..].binary_search_by(|n|match arr[last_ascending].cmp(n){Ordering::Equal=>Ordering::Greater,ord=>ord,}).unwrap_err();arr.swap(last_ascending,last_ascending+swap_with);arr[last_ascending+1..].reverse();true}type V<T> =Vec<T>;type VV<T> =V<V<T>>;type Set<T> =BTreeSet<T>;type US=usize;type UU=(US,US);type UUU=(US,US,US);pub fn to_digit_array(a:u64)->V<US>{let mut ans:V<US> =V::new();let mut a=a;while a>0{ans.push((a%10)as usize);a/=10;}ans.reverse();ans}pub fn ceil_int(a:u64,b:u64)->u64{let mut r=a/b;if a%b!=0{r+=1;}r}pub fn sumxor(n:u64)->u64{let md=n%4;match md{0=>n,1=>1,2=>n+1,3=>0,_=>0,}}pub fn sumxor_range(l:u64,r:u64)->u64{if l==0{sumxor(r)}else{sumxor(l-1)^sumxor(r)}}pub fn mod_in_range(l:u64,r:u64,k:u64,m:u64)->(u64,u64,u64){let first_oc=if l<=k{k}else{k+(ceil_int(l-k,m))*m};if first_oc>r{return(0,0,0);}let last_oc=first_oc+((r-first_oc)/m)*m;let oc=((last_oc-k)-(first_oc-k))/m+1;(oc,first_oc,last_oc)}#[doc=" https://www.geeksforgeeks.org/sum-of-products-of-all-possible-k-size-subsets-of-the-given-array/"]#[doc=" In O(n*k)"]pub fn sum_of_product(arr:&Vec<US>,k:usize)->US{let n=arr.len();let mut dp:Vec<US> =vec![0;n+1];let mut cur_sum=0;for i in 1..=n{dp[i]=arr[i-1];cur_sum+=arr[i-1];}for _ in 2..=k{let mut temp_sum=0;for j in 1..=n{cur_sum-=dp[j];dp[j]=arr[j-1]*cur_sum;temp_sum+=dp[j];}cur_sum=temp_sum;}cur_sum}pub fn better_array_debug<T>(a:&V<T>)where T:Debug,{a.iter().enumerate().for_each(|(i,x)|println!("{i:4}: {x:?}"));}pub fn better_2_array_debug<T,D>(a:&V<T>,b:&V<D>)where T:Debug,D:Debug,{(0..a.len()).for_each(|i|{println!("{i:4}: {:?} -- {:4?}",a[i],b[i]);})}pub fn read_n_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<T>){let n=read_1_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,v)}pub fn read_n_m_and_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,US,V<T>){let(n,m)=read_2_number(line,reader,0usize);let v=read_vec_template(line,reader,default);(n,m,v)}pub fn read_n_and_array_of_pair<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(US,V<(T,T)>){let n=read_1_number(line,reader,0usize);let mut v:V<(T,T)> =V::new();v.reserve(n);(0..n).for_each(|_|{let x=read_2_number(line,reader,default);v.push(x);});(n,v)}pub fn read_n_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,V<T>,V<T>){let n=read_1_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,a,b)}pub fn read_n_m_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,V<T>,V<T>){let(n,m)=read_2_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,a,b)}pub fn read_n_m_k_and_2_array<T:FromStr+Copy>(line:&mut String,reader:&mut BufReader<Stdin>,default:T,)->(T,T,T,V<T>,V<T>){let(n,m,k)=read_3_number(line,reader,default);let a=read_vec_template(line,reader,default);let b=read_vec_template(line,reader,default);(n,m,k,a,b)}pub fn read_edge_list(m:usize,line:&mut String,reader:&mut BufReader<Stdin>)->V<(UU)>{let mut el:V<UU> =V::new();el.reserve(m);(0..m).for_each(|_|{let(u,v)=read_2_number(line,reader,0usize);el.push((u-1,v-1));});el}pub fn query(l:u64,r:u64,re:&mut BufReader<Stdin>,li:&mut String)->u64{println!("? {l} {r}");let ans=read_1_number(li,re,0u64);ans}}pub mod xor_basic{pub use crate::__cargo_equip::prelude::*;#[doc=" Structure that represent the basic of the vector space Z(d,2)"]#[doc=" Also keep track of the size and added size to count various things."]#[derive(Clone)]pub struct XorBasic{pub bases:Vec<u64>,pub sz:usize,pub set_sz:usize,}fn power_mod(a:u64,b:u64,m:u64)->u64{let mut res=1u64;let mut x=a;let mut cur=b;while cur>0{if cur%2==1{res=(res*x)%m;}x=(x*x)%m;cur/=2;}res}impl XorBasic{#[doc=" Init basic with the number of dimension. Usually is the number of bit."]pub fn new(d:usize)->Self{XorBasic{bases:vec![0;d],sz:0,set_sz:0,}}#[doc=" Insert a vector (represent by mask) into the basic."]pub fn insert(&mut self,mask:u64){self.set_sz+=1;if self.sz==self.bases.len(){return;}let mut mask=mask;for i in(0..self.bases.len()).rev(){if(mask&(1<<i))==0{continue;}if self.bases[i]==0{self.bases[i]=mask;self.sz+=1;}mask^=self.bases[i];}}#[doc=" Insert the vector into the basic, with the step along the way on how to create this mask."]#[doc=" If you xor all of them together, you will get back the mask."]pub fn insert_with_steps(&mut self,mask:u64)->Vec<u64>{let mut steps=Vec::new();self.set_sz+=1;if self.sz==self.bases.len(){return steps;}let mut mask=mask;for i in(0..self.bases.len()).rev(){if(mask&(1<<i))==0{continue;}if self.bases[i]==0{self.bases[i]=mask;self.sz+=1;}steps.push(self.bases[i]);mask^=self.bases[i];}steps}#[doc=" Given a representable mask, recreate mask using sumxor of some basic."]pub fn xor_steps(&mut self,mask:u64)->Vec<u64>{let mut steps=Vec::new();let mut mask=mask;for i in(0..self.bases.len()).rev(){if(mask&(1<<i))==0{continue;}steps.push(self.bases[i]);mask^=self.bases[i];}steps}#[doc=" Check if a vector (represent by mask) is representable using the current basic."]pub fn is_representable(&self,mask:u64)->bool{if self.sz==self.bases.len(){return true;}let mut mask=mask;for i in(0..self.bases.len()).rev(){if(mask&(1<<i))==0{continue;}if self.bases[i]==0{return false;}mask^=self.bases[i];}return true;}#[doc=" Count the number of way to represent mask using the curent basic and set size."]#[doc=" If it's representable, then the ans is 2^(set_sz - sz)."]pub fn count_representable(&self,mask:u64)->u64{if!self.is_representable(mask){return 0;}return 1u64<<(self.set_sz-self.sz);}#[doc=" Count the number of way to represent mask using the curent basic and set size."]#[doc=" If it's representable, then the ans is 2^(set_sz - sz). Input a modulo for fast calculate."]pub fn count_representable_mod(&self,mask:u64,md:u64)->u64{if!self.is_representable(mask){return 0;}return power_mod(2u64,(self.set_sz-self.sz)as u64,md);}#[doc=" Get the maximum vector that is representable by the basic"]pub fn get_max(&self)->u64{let mut ans=0;for i in(0..self.bases.len()).rev(){if self.bases[i]==0{continue;}if(ans&(1<<i))==0{continue;}ans^=self.bases[i];}ans}#[doc=" Gauss-Jordan Elimination to turn all vector in the basic to single form,"]#[doc=" in which every key bit (the highest bit of a vector) on appear in 1 vector."]#[doc=" This is useful for other DP calculation, since every bit is only present once"]#[doc=" and allow for sumxor to only inc the number of on bit."]pub fn eliminate(&self)->Vec<u64>{let mut op=self.bases.clone();for j in 0..self.sz{for i in 0..j{op[i]=op[i].min(op[i]^op[j]);}}op.sort();op.reverse();op}}#[doc=" Count the number of subset of a so that sumxor is 0."]#[doc=" Go one by one and update the basic, base calculation on count_rep(a[i]) and count_0."]pub fn num_subset_zero(a:&[u64])->u64{let md=1000000007;let mut basic=XorBasic::new(32);let mut count_0=0u64;let mut ans=0u64;for&mask in a.iter(){if mask==0{ans*=2;ans+=1;ans%=md;count_0+=1;}else{let c=basic.count_representable_mod(mask,md);let total=c*power_mod(2u64,count_0,md);ans+=total;ans%=md;basic.insert(mask);}}ans}#[doc=" Count #ways to pick a subset, which sumxor has x bit."]pub fn count_representable_with_x_bit(a:&[u64])->Vec<u64>{let md=1000000007;let m=32;let mut basic=XorBasic::new(m);for&x in a.iter(){basic.insert(x);}let el=basic.eliminate();let mut f=vec![0u64;m+1];f[0]=1;let mut cur=0u64;for i in 1u64..(1<<basic.sz){cur^=el[i.trailing_zeros()as usize]as u64;f[cur.count_ones()as usize]+=1;f[cur.count_ones()as usize]%=md;}let c=power_mod(2u64,(basic.set_sz-basic.sz)as u64,md);let mut ans=vec![c;m+1];for i in 0..=m{ans[i]=(ans[i]*f[i])%md;}ans}}use xor_basic::XorBasic;type VV<T> =Vec<Vec<T>>;type US=usize;fn solve(reader:&mut BufReader<Stdin>,line:&mut String,out:&mut BufWriter<StdoutLock>){let default=0usize;let x=utils::read_1_number(line,reader,0u64);let m=((x*x).ilog2()+3)as usize;let mut basic=XorBasic::new(m);basic.insert(x);let mut ans:Vec<(u64,u64,bool)> =Vec::new();let mut rng=SmallRng::new(177013);let mut seen:BTreeSet<u64> =BTreeSet::new();seen.insert(x);while!basic.is_representable(1){let mut random1=0;for i in(0..m).rev(){if basic.bases[i]!=0&&rng.next_u32()%2==1{random1^=basic.bases[i];}}let mut random2=0;for i in(0..m).rev(){if basic.bases[i]!=0&&rng.next_u32()%2==1{random2^=basic.bases[i];}}if random1==0||random2==0{continue;}let nx=random1+random2;if nx>=(1<<m){continue;}if!basic.is_representable(nx){if!seen.contains(&random1){let steps=basic.xor_steps(random1);let mut cur=steps[0];for&st in steps[1..].iter(){if!seen.contains(&(cur^st)){ans.push((cur,st,false));}cur^=st;seen.insert(cur);}}if!seen.contains(&random2){let steps=basic.xor_steps(random2);let mut cur=steps[0];for&st in steps[1..].iter(){if!seen.contains(&(cur^st)){ans.push((cur,st,false));}cur^=st;seen.insert(cur);}}ans.push((random1,random2,true));seen.insert(nx);let steps=basic.insert_with_steps(nx);let mut cur=nx;for&st in steps[..steps.len()-1].iter(){if!seen.contains(&(cur^st)){ans.push((cur,st,false));}cur^=st;seen.insert(cur);}}}writeln!(out,"{}",ans.len()).unwrap();for&(x,y,is_pl)in ans.iter(){writeln!(out,"{x} {} {y}",if is_pl{"+"}else{"^"}).unwrap();}}fn main(){let mut reader=BufReader::new(stdin());let mut line=String::new();let mut out=BufWriter::new(stdout().lock());solve(&mut reader,&mut line,&mut out);}#[doc="  # Bundled libraries"]#[doc=" "]#[doc="  - `path+file:///home/quocbaodo205/Documents/cp_rust#0.1.0` published in **missing** licensed under **missing** as `crate::__cargo_equip::crates::cp_rust`"]#[allow(unused)]mod __cargo_equip{pub(crate)mod crates{pub mod cp_rust{}}pub(crate)mod macros{pub mod cp_rust{}}pub(crate)mod prelude{pub use crate::__cargo_equip::crates::*;}mod preludes{pub mod cp_rust{}}}